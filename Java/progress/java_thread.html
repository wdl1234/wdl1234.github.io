<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="VuePress 2.0.0-beta.60">
    <style>
      :root {
        --c-bg: #fff;
      }
      html.dark {
        --c-bg: #22272e;
      }
      html, body {
        background-color: var(--c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem('vuepress-color-scheme');
			const systemDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
			if (userMode === 'dark' || (userMode !== 'light' && systemDarkMode)) {
				document.documentElement.classList.toggle('dark', true);
			}
    </script>
    <link rel="icon" href="/images/love.jpg"><link rel="manifest" href="/images/love.jpg"><link rel="apple-touch-icon" href="/images/love.jpg"><meta http-quiv="pragma" cotent="no-cache"><meta http-quiv="pragma" cotent="no-cache,must-revalidate"><meta http-quiv="expires" cotent="0"><title>并发编程 | 小头知识库</title><meta name="description" content="本库是个人学习的时候记录的笔记 对 Java 的一些基础知识、数据库知识、以及框架知识进行收集、整理（持续更新中）">
    <link rel="preload" href="/assets/style-fae0be7d.css" as="style"><link rel="stylesheet" href="/assets/style-fae0be7d.css">
    <link rel="modulepreload" href="/assets/app-97ed9e93.js"><link rel="modulepreload" href="/assets/framework-96b046e1.js"><link rel="modulepreload" href="/assets/java_thread.html-3b0a9e41.js"><link rel="modulepreload" href="/assets/java_thread.html-87791478.js"><link rel="prefetch" href="/assets/index.html-0ce61fa9.js" as="script"><link rel="prefetch" href="/assets/mysql_advance.html-d6219995.js" as="script"><link rel="prefetch" href="/assets/mysql_base.html-c6ab0552.js" as="script"><link rel="prefetch" href="/assets/mysql_high.html-55072139.js" as="script"><link rel="prefetch" href="/assets/interview.html-97c85ece.js" as="script"><link rel="prefetch" href="/assets/mongodb.html-0d0744b9.js" as="script"><link rel="prefetch" href="/assets/optimization.html-f016fef6.js" as="script"><link rel="prefetch" href="/assets/redis.html-6a25c044.js" as="script"><link rel="prefetch" href="/assets/java_juc.html-50bf328a.js" as="script"><link rel="prefetch" href="/assets/java_jvm.html-d0967276.js" as="script"><link rel="prefetch" href="/assets/java_jvm_optimize.html-dd24d727.js" as="script"><link rel="prefetch" href="/assets/java_thread_pool.html-75a567a4.js" as="script"><link rel="prefetch" href="/assets/java_base.html-056f7ff5.js" as="script"><link rel="prefetch" href="/assets/java_exception.html-9993d94e.js" as="script"><link rel="prefetch" href="/assets/java_Io.html-e3db5f8a.js" as="script"><link rel="prefetch" href="/assets/java_list.html-31f4b5fd.js" as="script"><link rel="prefetch" href="/assets/java_new8.html-6dd646ec.js" as="script"><link rel="prefetch" href="/assets/java_object.html-a7de2f70.js" as="script"><link rel="prefetch" href="/assets/java_reflect.html-08c2a157.js" as="script"><link rel="prefetch" href="/assets/java_simple.html-c32db0db.js" as="script"><link rel="prefetch" href="/assets/java_web.html-d7f68a67.js" as="script"><link rel="prefetch" href="/assets/java_jsp.html-64f622e2.js" as="script"><link rel="prefetch" href="/assets/java_servlet.html-9dd1dd2c.js" as="script"><link rel="prefetch" href="/assets/404.html-60b35caa.js" as="script"><link rel="prefetch" href="/assets/index.html-9c30ae09.js" as="script"><link rel="prefetch" href="/assets/mysql_advance.html-36744e2f.js" as="script"><link rel="prefetch" href="/assets/mysql_base.html-76d5b36b.js" as="script"><link rel="prefetch" href="/assets/mysql_high.html-6bf4bb7d.js" as="script"><link rel="prefetch" href="/assets/interview.html-44bef611.js" as="script"><link rel="prefetch" href="/assets/mongodb.html-9ce18145.js" as="script"><link rel="prefetch" href="/assets/optimization.html-029c0d29.js" as="script"><link rel="prefetch" href="/assets/redis.html-365e35d9.js" as="script"><link rel="prefetch" href="/assets/java_juc.html-c4967054.js" as="script"><link rel="prefetch" href="/assets/java_jvm.html-b46b586e.js" as="script"><link rel="prefetch" href="/assets/java_jvm_optimize.html-19e3c625.js" as="script"><link rel="prefetch" href="/assets/java_thread_pool.html-dd60e235.js" as="script"><link rel="prefetch" href="/assets/java_base.html-d4efbd6b.js" as="script"><link rel="prefetch" href="/assets/java_exception.html-e16104bf.js" as="script"><link rel="prefetch" href="/assets/java_Io.html-16a286bf.js" as="script"><link rel="prefetch" href="/assets/java_list.html-761af11d.js" as="script"><link rel="prefetch" href="/assets/java_new8.html-a1e1909b.js" as="script"><link rel="prefetch" href="/assets/java_object.html-653740ef.js" as="script"><link rel="prefetch" href="/assets/java_reflect.html-d428cb40.js" as="script"><link rel="prefetch" href="/assets/java_simple.html-f3780249.js" as="script"><link rel="prefetch" href="/assets/java_web.html-bbbc7d6b.js" as="script"><link rel="prefetch" href="/assets/java_jsp.html-ff5b2ce7.js" as="script"><link rel="prefetch" href="/assets/java_servlet.html-22952a3e.js" as="script"><link rel="prefetch" href="/assets/404.html-46166703.js" as="script">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container"><!--[--><header class="navbar"><div class="toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a href="/" class=""><!----><span class="site-name">小头知识库</span></a></span><div class="navbar-items-wrapper" style=""><!--[--><!--]--><nav class="navbar-items can-hide"><!--[--><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="Java"><span class="title">Java</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="Java"><span class="title">Java</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>Java基础知识</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/Java/base/java_base.html" class="" aria-label="Java基础知识"><!--[--><!--]--> Java基础知识 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/Java/base/java_list.html" class="" aria-label="集合框架"><!--[--><!--]--> 集合框架 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/Java/base/java_Io.html" class="" aria-label="Java IO"><!--[--><!--]--> Java IO <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/Java/base/java_web.html" class="" aria-label="Java 网络编程"><!--[--><!--]--> Java 网络编程 <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>Java进阶知识</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/Java/progress/java_jvm.html" class="" aria-label="JVM"><!--[--><!--]--> JVM <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/Java/progress/java_jvm_optimize.html" class="" aria-label="JVM调优"><!--[--><!--]--> JVM调优 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a aria-current="page" href="/Java/progress/java_thread.html" class="router-link-active router-link-exact-active router-link-active" aria-label="并发编程"><!--[--><!--]--> 并发编程 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/Java/progress/java_juc.html" class="" aria-label="JUC"><!--[--><!--]--> JUC <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><!--]--></ul></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="数据库"><span class="title">数据库</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="数据库"><span class="title">数据库</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>Mysql</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/database/mysql_base.html" class="" aria-label="Mysql基础"><!--[--><!--]--> Mysql基础 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/database/mysql_high.html" class="" aria-label="Mysql高级"><!--[--><!--]--> Mysql高级 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/database/mysql_advance.html" class="" aria-label="Mysql进阶"><!--[--><!--]--> Mysql进阶 <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>Redis</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/redis/redis.html" class="" aria-label="Redis"><!--[--><!--]--> Redis <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>MongoDB</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/mongodb/mongodb.html" class="" aria-label="MongoDB"><!--[--><!--]--> MongoDB <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><!--]--></ul></div></div><div class="navbar-item"><a href="/others/" class="" aria-label="框架"><!--[--><!--]--> 框架 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/algorithm/" class="" aria-label="工具 "><!--[--><!--]--> 工具  <!--[--><!--]--></a></div><div class="navbar-item"><a href="/algorithm/" class="" aria-label="部署"><!--[--><!--]--> 部署 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/others/" class="" aria-label="算法"><!--[--><!--]--> 算法 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/others/" class="" aria-label="开发"><!--[--><!--]--> 开发 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/accumulate/" class="" aria-label="面试"><!--[--><!--]--> 面试 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/optimization/optimization.md/" class="" aria-label="项目优化"><!--[--><!--]--> 项目优化 <!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><button class="toggle-color-mode-button" title="toggle color mode"><svg style="" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg style="display:none;" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><form class="search-box" role="search"><input type="search" autocomplete="off" spellcheck="false" value><!----></form></div></header><!--]--><div class="sidebar-mask"></div><!--[--><aside class="sidebar"><nav class="navbar-items"><!--[--><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="Java"><span class="title">Java</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="Java"><span class="title">Java</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>Java基础知识</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/Java/base/java_base.html" class="" aria-label="Java基础知识"><!--[--><!--]--> Java基础知识 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/Java/base/java_list.html" class="" aria-label="集合框架"><!--[--><!--]--> 集合框架 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/Java/base/java_Io.html" class="" aria-label="Java IO"><!--[--><!--]--> Java IO <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/Java/base/java_web.html" class="" aria-label="Java 网络编程"><!--[--><!--]--> Java 网络编程 <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>Java进阶知识</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/Java/progress/java_jvm.html" class="" aria-label="JVM"><!--[--><!--]--> JVM <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/Java/progress/java_jvm_optimize.html" class="" aria-label="JVM调优"><!--[--><!--]--> JVM调优 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a aria-current="page" href="/Java/progress/java_thread.html" class="router-link-active router-link-exact-active router-link-active" aria-label="并发编程"><!--[--><!--]--> 并发编程 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/Java/progress/java_juc.html" class="" aria-label="JUC"><!--[--><!--]--> JUC <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><!--]--></ul></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="数据库"><span class="title">数据库</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="数据库"><span class="title">数据库</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>Mysql</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/database/mysql_base.html" class="" aria-label="Mysql基础"><!--[--><!--]--> Mysql基础 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/database/mysql_high.html" class="" aria-label="Mysql高级"><!--[--><!--]--> Mysql高级 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/database/mysql_advance.html" class="" aria-label="Mysql进阶"><!--[--><!--]--> Mysql进阶 <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>Redis</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/redis/redis.html" class="" aria-label="Redis"><!--[--><!--]--> Redis <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>MongoDB</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/mongodb/mongodb.html" class="" aria-label="MongoDB"><!--[--><!--]--> MongoDB <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><!--]--></ul></div></div><div class="navbar-item"><a href="/others/" class="" aria-label="框架"><!--[--><!--]--> 框架 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/algorithm/" class="" aria-label="工具 "><!--[--><!--]--> 工具  <!--[--><!--]--></a></div><div class="navbar-item"><a href="/algorithm/" class="" aria-label="部署"><!--[--><!--]--> 部署 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/others/" class="" aria-label="算法"><!--[--><!--]--> 算法 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/others/" class="" aria-label="开发"><!--[--><!--]--> 开发 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/accumulate/" class="" aria-label="面试"><!--[--><!--]--> 面试 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/optimization/optimization.md/" class="" aria-label="项目优化"><!--[--><!--]--> 项目优化 <!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><ul class="sidebar-items"><!--[--><li><p tabindex="0" class="sidebar-item sidebar-heading active">Java进阶 <!----></p><ul style="" class="sidebar-item-children"><!--[--><li><a href="/Java/progress/java_jvm.html" class="sidebar-item" aria-label="JVM"><!--[--><!--]--> JVM <!--[--><!--]--></a><!----></li><li><a href="/Java/progress/java_jvm_optimize.html" class="sidebar-item" aria-label="JVM调优"><!--[--><!--]--> JVM调优 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/Java/progress/java_thread.html" class="router-link-active router-link-exact-active router-link-active sidebar-item active" aria-label="并发编程"><!--[--><!--]--> 并发编程 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/Java/progress/java_thread.html#概念" class="router-link-active router-link-exact-active sidebar-item" aria-label="概念"><!--[--><!--]--> 概念 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/Java/progress/java_thread.html#线程和进程" class="router-link-active router-link-exact-active sidebar-item" aria-label="线程和进程"><!--[--><!--]--> 线程和进程 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/Java/progress/java_thread.html#并发和并行" class="router-link-active router-link-exact-active sidebar-item" aria-label="并发和并行"><!--[--><!--]--> 并发和并行 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/Java/progress/java_thread.html#线程上下文切换" class="router-link-active router-link-exact-active sidebar-item" aria-label="线程上下文切换"><!--[--><!--]--> 线程上下文切换 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/Java/progress/java_thread.html#线程的基本实现方式" class="router-link-active router-link-exact-active sidebar-item" aria-label="线程的基本实现方式"><!--[--><!--]--> 线程的基本实现方式 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/Java/progress/java_thread.html#_1、继承thread类" class="router-link-active router-link-exact-active sidebar-item" aria-label="1、继承Thread类"><!--[--><!--]--> 1、继承Thread类 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/Java/progress/java_thread.html#_2、实现runnable接口" class="router-link-active router-link-exact-active sidebar-item" aria-label="2、实现Runnable接口"><!--[--><!--]--> 2、实现Runnable接口 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/Java/progress/java_thread.html#_3、callable和future创建线程" class="router-link-active router-link-exact-active sidebar-item" aria-label="3、Callable和Future创建线程"><!--[--><!--]--> 3、Callable和Future创建线程 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/Java/progress/java_thread.html#线程状态" class="router-link-active router-link-exact-active sidebar-item" aria-label="线程状态"><!--[--><!--]--> 线程状态 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/Java/progress/java_thread.html#wait与sleep-的区别" class="router-link-active router-link-exact-active sidebar-item" aria-label="wait与sleep()的区别"><!--[--><!--]--> wait与sleep()的区别 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/Java/progress/java_thread.html#多线程源码剖析" class="router-link-active router-link-exact-active sidebar-item" aria-label="多线程源码剖析"><!--[--><!--]--> 多线程源码剖析 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/Java/progress/java_thread.html#线程安全" class="router-link-active router-link-exact-active sidebar-item" aria-label="线程安全"><!--[--><!--]--> 线程安全 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/Java/progress/java_thread.html#线程安全问题" class="router-link-active router-link-exact-active sidebar-item" aria-label="线程安全问题"><!--[--><!--]--> 线程安全问题 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/Java/progress/java_thread.html#引发线程安全问题的根本原因" class="router-link-active router-link-exact-active sidebar-item" aria-label="引发线程安全问题的根本原因"><!--[--><!--]--> 引发线程安全问题的根本原因 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/Java/progress/java_thread.html#解决线程安全问题" class="router-link-active router-link-exact-active sidebar-item" aria-label="解决线程安全问题"><!--[--><!--]--> 解决线程安全问题 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/Java/progress/java_thread.html#线程并发三大特性" class="router-link-active router-link-exact-active sidebar-item" aria-label="线程并发三大特性"><!--[--><!--]--> 线程并发三大特性 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/Java/progress/java_thread.html#指令重排" class="router-link-active router-link-exact-active sidebar-item" aria-label="指令重排"><!--[--><!--]--> 指令重排 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/Java/progress/java_thread.html#cpu和缓存一致性" class="router-link-active router-link-exact-active sidebar-item" aria-label="CPU和缓存一致性"><!--[--><!--]--> CPU和缓存一致性 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/Java/progress/java_thread.html#java内存模型" class="router-link-active router-link-exact-active sidebar-item" aria-label="Java内存模型"><!--[--><!--]--> Java内存模型 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/Java/progress/java_thread.html#jmm内存模型抽象结构示意图" class="router-link-active router-link-exact-active sidebar-item" aria-label="JMM内存模型抽象结构示意图"><!--[--><!--]--> JMM内存模型抽象结构示意图 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/Java/progress/java_thread.html#jmm线程操作内存基本规则" class="router-link-active router-link-exact-active sidebar-item" aria-label="JMM线程操作内存基本规则"><!--[--><!--]--> JMM线程操作内存基本规则 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/Java/progress/java_thread.html#可见性" class="router-link-active router-link-exact-active sidebar-item" aria-label="可见性"><!--[--><!--]--> 可见性 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/Java/progress/java_thread.html#happens-before规则" class="router-link-active router-link-exact-active sidebar-item" aria-label="happens-before规则"><!--[--><!--]--> happens-before规则 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/Java/progress/java_thread.html#线程同步-synchronized" class="router-link-active router-link-exact-active sidebar-item" aria-label="线程同步-synchronized"><!--[--><!--]--> 线程同步-synchronized <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/Java/progress/java_thread.html#作用" class="router-link-active router-link-exact-active sidebar-item" aria-label="作用"><!--[--><!--]--> 作用 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/Java/progress/java_thread.html#如何解决可见性问题" class="router-link-active router-link-exact-active sidebar-item" aria-label="如何解决可见性问题"><!--[--><!--]--> 如何解决可见性问题 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/Java/progress/java_thread.html#synchronized是如何实现同步" class="router-link-active router-link-exact-active sidebar-item" aria-label="Synchronized是如何实现同步"><!--[--><!--]--> Synchronized是如何实现同步 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/Java/progress/java_thread.html#synchronized原理" class="router-link-active router-link-exact-active sidebar-item" aria-label="synchronized原理"><!--[--><!--]--> synchronized原理 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/Java/progress/java_thread.html#锁优化" class="router-link-active router-link-exact-active sidebar-item" aria-label="锁优化"><!--[--><!--]--> 锁优化 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/Java/progress/java_thread.html#volatile关键字" class="router-link-active router-link-exact-active sidebar-item" aria-label="Volatile关键字"><!--[--><!--]--> Volatile关键字 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/Java/progress/java_thread.html#volatile简介" class="router-link-active router-link-exact-active sidebar-item" aria-label="Volatile简介"><!--[--><!--]--> Volatile简介 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/Java/progress/java_thread.html#volatile实现原理" class="router-link-active router-link-exact-active sidebar-item" aria-label="Volatile实现原理"><!--[--><!--]--> Volatile实现原理 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/Java/progress/java_thread.html#jmm-内存屏障插入策略" class="router-link-active router-link-exact-active sidebar-item" aria-label="JMM 内存屏障插入策略"><!--[--><!--]--> JMM 内存屏障插入策略 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/Java/progress/java_thread.html#volatile缺陷" class="router-link-active router-link-exact-active sidebar-item" aria-label="Volatile缺陷"><!--[--><!--]--> Volatile缺陷 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/Java/progress/java_thread.html#volatile和synchronized特点比较" class="router-link-active router-link-exact-active sidebar-item" aria-label="Volatile和Synchronized特点比较"><!--[--><!--]--> Volatile和Synchronized特点比较 <!--[--><!--]--></a><!----></li><!--]--></ul></li><!--]--></ul></li><li><a href="/Java/progress/java_juc.html" class="sidebar-item" aria-label="JUC"><!--[--><!--]--> JUC <!--[--><!--]--></a><!----></li><li><a href="/Java/progress/java_thread_pool.html" class="sidebar-item" aria-label="线程池"><!--[--><!--]--> 线程池 <!--[--><!--]--></a><!----></li><!--]--></ul></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="page"><!--[--><!--]--><div class="theme-default-content"><!--[--><!--]--><div><h1 id="并发编程" tabindex="-1"><a class="header-anchor" href="#并发编程" aria-hidden="true">#</a> 并发编程</h1><h2 id="概念" tabindex="-1"><a class="header-anchor" href="#概念" aria-hidden="true">#</a> 概念</h2><h3 id="线程和进程" tabindex="-1"><a class="header-anchor" href="#线程和进程" aria-hidden="true">#</a> 线程和进程</h3><p>进程：是指内存运行的一个应用程序，是系统运行程序的基本单位，是程序的一次执行过程</p><p>线程：是进程中的一个执行单元，负责当前进程中的任务的执行，一个进程会产生很多线程</p><p>两者主要区别：每个进程都有独立内存空间。线程之间的堆空间和方法区共享，线程栈空间和 程序计数器是独立的。线程消耗资源比进程小的多</p><h3 id="并发和并行" tabindex="-1"><a class="header-anchor" href="#并发和并行" aria-hidden="true">#</a> 并发和并行</h3><p>并发Concurrency：同一时间段，多个任务都在执行，单位时间内不一定是同时执行</p><p>并行Parallel：单位时间内，多个任务同时执行，单位时间内一定是同时执行</p><img src="/images/thread/1.png" alt="jvm"><h3 id="线程上下文切换" tabindex="-1"><a class="header-anchor" href="#线程上下文切换" aria-hidden="true">#</a> 线程上下文切换</h3><p>一个CPU同一时刻只能被一个线程使用，为了提升效率CPU采用时间片算法将CPU时间片轮流分配给多个线 程。在分配的时间片内线程执行，如果没有执行完毕，则需要挂起然后把CPU让给其他线程。</p><p>那么问题来了：线程下次运行时，怎么知道上次运行到哪里呢？<br> ➢ CPU切换线程，会把当前线程的执行位置记录下来，用于下次执行时找到准确位置<br> ➢ 线程执行位置的记录与加载过程就叫做上下文切换<br> ➢ 线程执行位置记录在程序计数器</p><p>上下文切换过程：</p><p>① 挂起线程01，将线程在CPU的状态（上下文）存储在内存<br> ② 恢复线程02，将内存中的上下文在CPU寄存器中恢复<br> ③ 调转到程序计数器所指定的位置，继续执行之后的代码</p><img src="/images/thread/2.png" alt="jvm"><h2 id="线程的基本实现方式" tabindex="-1"><a class="header-anchor" href="#线程的基本实现方式" aria-hidden="true">#</a> 线程的基本实现方式</h2><h3 id="_1、继承thread类" tabindex="-1"><a class="header-anchor" href="#_1、继承thread类" aria-hidden="true">#</a> 1、继承Thread类</h3><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// 线程类</span>
<span class="token comment">// 1.定义线程类 Remix_Thread 继承 Thread 类</span>
<span class="token keyword">class</span> <span class="token class-name">Remix_Thread</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span>
    <span class="token doc-comment comment">/**
     * 示例：使用继承Thread类的方式创建一个线程，实现输出1-5
     * 2.子类中重写Thread类中的run方法
     */</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">6</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 测试类 Remix_Test</span>
<span class="token keyword">class</span> <span class="token class-name">Remix_Test</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 方式一：继承Thread类</span>
        <span class="token comment">// 3.创建线程对象</span>
        <span class="token class-name">Remix_Thread</span> rt <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Remix_Thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 4.调用线程对象的start方法启动线程</span>
        rt<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_2、实现runnable接口" tabindex="-1"><a class="header-anchor" href="#_2、实现runnable接口" aria-hidden="true">#</a> 2、实现Runnable接口</h3><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// 1.定义线程实现类 Remix_Runnable类 实现Runnable接口</span>
<span class="token keyword">class</span> <span class="token class-name">Remix_Runnable</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>
    <span class="token doc-comment comment">/**
     * 示例：使用实现Runnable接口的方式创建一个线程，实现从1输出到5。
     * 2.实现类中重写Runnable接口中的run方法
     */</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">6</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Remix_Test</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 方式二：实现Runnable接口</span>
        <span class="token comment">// 3.创建Runnable接口的子类对象</span>
        <span class="token class-name">Remix_Runnable</span> rr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Remix_Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 4.通过Thread类创建线程对象</span>
        <span class="token comment">// 将Runnable接口的子类对象作为参数传递给Thread类的构造方法</span>
        <span class="token class-name">Thread</span> t1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>rr<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 5.调用Thread类的start方法启动线程</span>
        t1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_3、callable和future创建线程" tabindex="-1"><a class="header-anchor" href="#_3、callable和future创建线程" aria-hidden="true">#</a> 3、Callable和Future创建线程</h3><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// 1.定义子类Remix_Callable，实现Callable接口，带有返回值；</span>
<span class="token keyword">class</span> <span class="token class-name">Remix_Callable</span> <span class="token keyword">implements</span> <span class="token class-name">Callable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token doc-comment comment">/**
     * 示例：使用Callable和Future的方式创建一个线程，实现从1输出到5。
     * 2.子类中重写Callable接口中的call方法
     */</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">Integer</span> <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token class-name">Integer</span> num <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
            num <span class="token operator">=</span> i<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> num<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Remix_Test</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 方式三：过Callable和Future创建线程</span>
        <span class="token comment">// 3.创建Callable接口的实现类对象</span>
        <span class="token class-name">Remix_Callable</span> rc <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Remix_Callable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 4.使用FutureTask类来包装Callable对象</span>
        <span class="token class-name">FutureTask</span> task <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FutureTask</span><span class="token punctuation">(</span>rc<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 5.通过Thread类的构造器创建线程对象</span>
        <span class="token comment">// 使用FutureTask象作为Thread对象的 target创建</span>
        <span class="token comment">// 6.创建Thread对象并调用start方法启动线程</span>
        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 输出线程执行后的返回值</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token comment">// 7.调用FutureTask对象的get方法来获得线程执行结束后的返回值；</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>task<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ExecutionException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>总结： 实现Runnable接口比继承Thread类所具有的优势：<br> 适合多个相同的程序代码的线程去共享同一个资源。<br> 可以避免java中的单继承的局限性。<br> 增加程序的健壮性，实现解耦操作，代码可以被多个线程共享，代码和线程独立。<br> 线程池只能放入实现Runable或Callable类线程，不能直接放入继承Thread的类。</p><h2 id="线程状态" tabindex="-1"><a class="header-anchor" href="#线程状态" aria-hidden="true">#</a> 线程状态</h2><p>01-线程从出生到死亡会出现六种状态：<br> ➢ ①New（新建）、②Runnable（可运行） 、③Terminated（终止） ➢ ④Blocked（锁阻塞）、⑤Waiting（无限等待）、⑥Timed_Waiting（超时等待）</p><img src="/images/thread/3.png" alt="jvm"><h3 id="wait与sleep-的区别" tabindex="-1"><a class="header-anchor" href="#wait与sleep-的区别" aria-hidden="true">#</a> wait与sleep()的区别</h3><p>主要区别：sleep()方法没有释放锁，wait()方法释放了锁<br> ➢ 两者都可以暂停线程执行：wait()常用于线程间交互/通信，sleep()用于暂停线程执行<br> ➢ wait()方法被调用后，需要别的线程调用同一个对象的notify和notifyAll。超时苏醒使用wait(long)方法<br> ➢ sleep()方法执行完成后，线程会自动苏醒</p><h2 id="多线程源码剖析" tabindex="-1"><a class="header-anchor" href="#多线程源码剖析" aria-hidden="true">#</a> 多线程源码剖析</h2><img src="/images/thread/4.png" alt="jvm"><p>流程小结：<br> ① 线程类被JVM加载时会绑定native方法与对应的C++方法<br> ② start()方法执行：<br> ➢ start()➔native start0()➔JVM_Thread➔ 创建线程JavaThread::JavaThread<br> ③ 创建OS线程，指定OS线程运行入口：<br> ➢ 创建线程构造方法➔ 创建OS线程➔指定OS线程执行入口，就是线程的run()方法<br> ④ 启动OS线程，运行时会调用指定的运行入口run()方法。至此，实现一个的线程运行<br> ⑤ 创建线程的过程是线程安全的，基于操作系统互斥量（MutexLocker）保证互斥，所以说创建线程性能很差</p><img src="/images/thread/5.png" alt="jvm"><img src="/images/thread/6.png" alt="jvm"><img src="/images/thread/7.png" alt="jvm"><h2 id="线程安全" tabindex="-1"><a class="header-anchor" href="#线程安全" aria-hidden="true">#</a> 线程安全</h2><h3 id="线程安全问题" tabindex="-1"><a class="header-anchor" href="#线程安全问题" aria-hidden="true">#</a> 线程安全问题</h3><p>➢ 多个线程同时执行，可能会运行同一行代码，如果程序每次运行结果与单线程执行结果一致，且变量的 预期值也一样，就是线程安全的，反之则是线程不安全。</p><h3 id="引发线程安全问题的根本原因" tabindex="-1"><a class="header-anchor" href="#引发线程安全问题的根本原因" aria-hidden="true">#</a> 引发线程安全问题的根本原因</h3><p>多个线程共享变量</p><p>➢ 如果多个线程对共享变量只有读操作，无写操作，那么此操作是线程安全的<br> ➢ 如果多个线程同时执行共享变量的写和读操作，则操作不是线程安全的</p><h3 id="解决线程安全问题" tabindex="-1"><a class="header-anchor" href="#解决线程安全问题" aria-hidden="true">#</a> 解决线程安全问题</h3><p>➢ 同步机制Synchronized<br> ➢ Volatile关键字：内存屏障<br> ➢ 原子类：CAS<br> ➢ 锁：AQS<br> ➢ 并发容器</p><h2 id="线程并发三大特性" tabindex="-1"><a class="header-anchor" href="#线程并发三大特性" aria-hidden="true">#</a> 线程并发三大特性</h2><p>01-并发编程最重要的三个特性：<br> ➢ 原子性：一个系列指令代码，要么全执行，要么都不执行，执行过程不能被打断<br> ➢ 有序性：程序代码按照先后顺序执行<br> ➢ 为什么会出现无序问题呢？因为指令重排<br> ➢ 可见性：当多个线程访问同一个变量时，一个线程修改了共享变量的值，其他线程能够立即看到<br> ➢ 为什么会出现不可见问题呢？因为Java内存模型（JMM)</p><h3 id="指令重排" tabindex="-1"><a class="header-anchor" href="#指令重排" aria-hidden="true">#</a> 指令重排</h3><p>编译器和处理器会对执行指令进行重排序优化，目的是提高程序运行效率。现象是，我们编写的Java代码 语句的先后顺序，不一定是按照我们写的顺序执行。</p><img src="/images/thread/8.png" alt="jvm"><h3 id="cpu和缓存一致性" tabindex="-1"><a class="header-anchor" href="#cpu和缓存一致性" aria-hidden="true">#</a> CPU和缓存一致性</h3><p>➢ 在多核 CPU 中每个核都有自己的缓存，同一个数据的缓存与内存可能不一致<br> ➢ 为什么需要CPU缓存？随着CPU技术发展，CPU执行速度和内存读取速度差距越来越大，导致CPU每次操作内存都 要耗费很多等待时间。为了解决这个问题，在CPU和物理内存上新增高速缓存。<br> ➢ 程序在运行过程中会将运算所需数据从主内存复制到CPU高速缓存，当CPU计算直接操作高速缓存数据，运算结束 将结果刷回主内存。</p><h3 id="java内存模型" tabindex="-1"><a class="header-anchor" href="#java内存模型" aria-hidden="true">#</a> Java内存模型</h3><p>➢ Java为了保证满足原子性、可见性及有序性，诞生了一个重要的规范JSR133，Java内存模型简称JMM<br> ➢ JMM定义了共享内存系统中多线程应用读写操作行为的规范<br> ➢ JMM规范定义的规则，规范了内存的读写操作，从而保证指令执行的正确性<br> ➢ JMM规范解决了CPU多级缓存、处理器优化、指令重排等导致的内存访问问题<br> ➢ Java实现了JMM规范因此有了Synchronized、Volatile、锁等概念<br> ➢ JMM的实现屏蔽各种硬件和操作系统的差异，在各种平台下对内存的访问都能保证效果一致</p><h3 id="jmm内存模型抽象结构示意图" tabindex="-1"><a class="header-anchor" href="#jmm内存模型抽象结构示意图" aria-hidden="true">#</a> JMM内存模型抽象结构示意图</h3><p>➢ JMM定义共享变量何时写入，何时对另一个线程可见<br> ➢ 线程之间的共享变量存储在主内存<br> ➢ 每个线程都有一个私有的本地内存，本地内存存储共享变量的副本<br> ➢ 本地内存是抽象的，不真实存在，涵盖：缓存，写缓冲区，寄存器等</p><img src="/images/thread/9.png" alt="jvm"><h3 id="jmm线程操作内存基本规则" tabindex="-1"><a class="header-anchor" href="#jmm线程操作内存基本规则" aria-hidden="true">#</a> JMM线程操作内存基本规则</h3><p>① 线程操作共享变量必须在本地内存中，不能直接操作主内存的<br> ② 线程间无法直接访问对方的共享变量，需经过主内存传递</p><h3 id="可见性" tabindex="-1"><a class="header-anchor" href="#可见性" aria-hidden="true">#</a> 可见性</h3><p>什么是内存可见性？<br> ➢ 可见性是一个线程对共享变量的修改，能够及时被其他线程看到</p><p>举个栗子：线程A和线程B保证共享变量共享<br> ① 线程A把本地内存A的共享变量副本值更新到主内存<br> ② 线程B到主内存读取最新的共享变量</p><p>JMM通过控制线程与本地内存之间的交互，来保证内存可见性</p><h3 id="happens-before规则" tabindex="-1"><a class="header-anchor" href="#happens-before规则" aria-hidden="true">#</a> happens-before规则</h3><p>在JMM中使用happens-before规则约束编译器优化行为，Java允许编译器优化，但是不能无条件优化。<br> 如果一个操作的执行结果需要对另一个操作可见，那么这两个操作必须存在happens-before的关系！</p><p>程序员需要关注的happens-before规则：<br> ➢ 程序顺序规则：一个线程中的每个操作，happens-before于该线程中的任意后续操作<br> ➢ 锁规则：对一个锁的解锁， happens-before与随后对这个锁的加锁<br> ➢ Volatile变量规则：对一个volatile修饰的变量的写， happens-before与任意后续对这个变量的读<br> ➢ 传递性：如果A happens-before B，B happens-before C，那么A happens-before C</p><h2 id="线程同步-synchronized" tabindex="-1"><a class="header-anchor" href="#线程同步-synchronized" aria-hidden="true">#</a> 线程同步-synchronized</h2><h3 id="作用" tabindex="-1"><a class="header-anchor" href="#作用" aria-hidden="true">#</a> 作用</h3><p>保证方法或代码块在多线程环境运行时，同一个时刻只有一个线程执行代码块</p><p>保证方法或代码块在多线程环境运行时，同一个时刻只有一个线程执行代码块。<br> ➢ JDK1.6之前，synchronized的实现依赖于OS底层互斥锁的MutexLock，存在严重的性能问题，是一个重量级锁<br> ➢ JDK1.6之后，Java对synchronized进行的了一系列优化，实现方式也改为Monitor（管程）了，性能与JUC锁比不相上下<br> ➢ 一句话：有了Synchronized，就线程安全了，保证原子性、可见性、有序性</p><p>可以修饰方法（静态和非静态）和代码块：<br> ➢ 同步代码块的锁：当前对象，字节码对象，其他对象<br> ➢ 非静态同步方法：锁当前对象<br> ➢ 静态同步方法：锁是当前类的Class对象</p><h3 id="如何解决可见性问题" tabindex="-1"><a class="header-anchor" href="#如何解决可见性问题" aria-hidden="true">#</a> 如何解决可见性问题</h3><p>JMM对于Synchronized的规定：<br> ➢ 加锁前：必须把自己本地内存中共享变量的最新值刷到主内存<br> ➢ 加锁时：清空本地内存中的共享变量，从主内存中读取共享变量最新的值</p><h3 id="synchronized是如何实现同步" tabindex="-1"><a class="header-anchor" href="#synchronized是如何实现同步" aria-hidden="true">#</a> Synchronized是如何实现同步</h3><p>同步操作主要是monitorenter和monitorexit两个jvm指令实现。背后原理是Monitor（管程）</p><h3 id="synchronized原理" tabindex="-1"><a class="header-anchor" href="#synchronized原理" aria-hidden="true">#</a> synchronized原理</h3><p>什么是Monitor<br> ➢ Monitor意译为管程，直译为监视器。所谓管程，就是管理共享变量及对共享变量操作的过程。让这个过 程可以并发执行。<br> ➢ Java所有对象都可以做为锁，为什么？<br> ➢ 因为每个对象都都有一个Monitor与之关联。然后线程对monitor执行lock和unlock操作，相当于对对象 执行上锁和解锁操作。<br> ➢ Synchronized里面不可以直接使用lock和unlock方法，但当我们使用了synchronized之后，JVM会自 动加入两个指令monitorenter和monitorexit，对应的就是lock和unlock操作。</p><p>Monitor的实现原理：将共享变量和对共享变量的操作统一封装起来</p><h3 id="锁优化" tabindex="-1"><a class="header-anchor" href="#锁优化" aria-hidden="true">#</a> 锁优化</h3><p>加了锁之后，不一定就是好的，很多程序员功力不够，盲目使用Synchronized，虽然解决了线程安全问题， 但也给系统埋下了迟缓的种子。</p><p>➢ 并发编程的几种情况：①只有一个线程运行，②两个线程交替执行，③多个线程并发执行<br> ➢ 经过实践经验总结：前两种情况，可以针对性优化<br> ➢ JDK1.6基于这两个场景，设计了两种优化方案：偏向锁和轻量级锁<br> ➢ 同步锁一共有四个状态：无锁，偏向锁，轻量级锁，重量级锁<br> ➢ JVM会视情况来逐渐升级锁，而不是上来就加重量级锁，这就是JDK1.6的锁优化</p><p>偏向锁：只有一个线程访问锁资源，偏向锁就会把整个同步措施消除</p><p>轻量级锁：只有两个线程交替竞争锁资源，如果线程竞争锁失败了不立即挂起，而是让它飞一会（自旋）， 在等待过程中可能锁就会被释放出来，这时尝试重新获取锁</p><h2 id="volatile关键字" tabindex="-1"><a class="header-anchor" href="#volatile关键字" aria-hidden="true">#</a> Volatile关键字</h2><h3 id="volatile简介" tabindex="-1"><a class="header-anchor" href="#volatile简介" aria-hidden="true">#</a> Volatile简介</h3><p>Java语言对volatile的定义：</p><p>➢ Java语言允许线程访问共享变量，为了确保共享变量能被准确的一致地更新，线程应该确保通过互斥锁单 独获取这个变量。Java语言提供了volatile，在某些情况下，它比锁要更方便。如果一个变量被声明成 volatile，JMM确保所有线程看到这个变量的值是一致的。</p><p>一句话：volatile可以保证多线程场景下共享变量的可见性、有序性</p><p>➢ 可见性：保证对此共享变量的修改，所有线程的可见性<br> ➢ 有序性：禁止指令重排序的优化，遵循JMM的happens-before规则</p><h3 id="volatile实现原理" tabindex="-1"><a class="header-anchor" href="#volatile实现原理" aria-hidden="true">#</a> Volatile实现原理</h3><p>volatile实现内存可见性原理：内存屏障<br> 内存屏障（Memory Barrier）是一种CPU指令，用于控制特定条件下的重排序和内存可见性问题。Java编译 器会根据内存屏障的规则禁止重排序。<br> ➢ Volatile变量写操作时：在写操作后加一条store屏障指令，让本地内存中变量的值能够刷新到主内存<br> ➢ Volatile变量读操作时：在读操作前加一条load屏障指令，及时读取到变量在主内存的值</p><img src="/images/thread/10.png" alt="jvm"><h3 id="jmm-内存屏障插入策略" tabindex="-1"><a class="header-anchor" href="#jmm-内存屏障插入策略" aria-hidden="true">#</a> JMM 内存屏障插入策略</h3><p>➢ 在每个 volatile 写前，插入StoreStore 屏障<br> ➢ 在每个 volatile 写后，插入StoreLoad 屏障<br> ➢ 在每个 volatile 读后，插入LoadLoad 屏障<br> ➢ 在每个 volatile 读后，插入LoadStore 屏障</p><img src="/images/thread/11.png" alt="jvm"><h3 id="volatile缺陷" tabindex="-1"><a class="header-anchor" href="#volatile缺陷" aria-hidden="true">#</a> Volatile缺陷</h3><p>存在原子性的问题：虽然volatile可以保证可见性，但是不能满足原子性</p><p>volatile适合使用场景：<br> 共享变量独立于其他变量和自己之前的值，这类变量单独使用的时候适合用volatile<br> ➢ 对共享变量的写入操作不依赖其当前值：例如++和--，就不行(比如count++,虽然是一行代码，但是却不是原子性，是jvm指令层面的原子操作)<br> ➢ 共享变量没有包含在有其他变量的不等式中</p><h3 id="volatile和synchronized特点比较" tabindex="-1"><a class="header-anchor" href="#volatile和synchronized特点比较" aria-hidden="true">#</a> Volatile和Synchronized特点比较</h3><img src="/images/thread/12.png" alt="jvm"></div><!--[--><!--]--></div><footer class="page-meta"><!----><div class="meta-item last-updated"><span class="meta-item-label">Last Updated: </span><!----></div><div class="meta-item contributors"><span class="meta-item-label">Contributors: </span><span class="meta-item-info"><!--[--><!--[--><span class="contributor" title="email: xt@qq.com">xt</span><!----><!--]--><!--]--></span></div></footer><nav class="page-nav"><p class="inner"><span class="prev"><a href="/Java/progress/java_jvm_optimize.html" class="" aria-label="JVM调优"><!--[--><!--]--> JVM调优 <!--[--><!--]--></a></span><span class="next"><a href="/Java/progress/java_juc.html" class="" aria-label="JUC"><!--[--><!--]--> JUC <!--[--><!--]--></a></span></p></nav><!--[--><!--]--></main><!--]--></div><!----><!--]--></div>
    <script type="module" src="/assets/app-97ed9e93.js" defer></script>
  </body>
</html>
