<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="VuePress 2.0.0-beta.60">
    <style>
      :root {
        --c-bg: #fff;
      }
      html.dark {
        --c-bg: #22272e;
      }
      html, body {
        background-color: var(--c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem('vuepress-color-scheme');
			const systemDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
			if (userMode === 'dark' || (userMode !== 'light' && systemDarkMode)) {
				document.documentElement.classList.toggle('dark', true);
			}
    </script>
    <link rel="icon" href="/images/love.jpg"><link rel="manifest" href="/images/love.jpg"><link rel="apple-touch-icon" href="/images/love.jpg"><meta http-quiv="pragma" cotent="no-cache"><meta http-quiv="pragma" cotent="no-cache,must-revalidate"><meta http-quiv="expires" cotent="0"><title>JUC | 小头知识库</title><meta name="description" content="本库是个人学习的时候记录的笔记 对 Java 的一些基础知识、数据库知识、以及框架知识进行收集、整理（持续更新中）">
    <link rel="preload" href="/assets/style-fae0be7d.css" as="style"><link rel="stylesheet" href="/assets/style-fae0be7d.css">
    <link rel="modulepreload" href="/assets/app-97ed9e93.js"><link rel="modulepreload" href="/assets/framework-96b046e1.js"><link rel="modulepreload" href="/assets/java_juc.html-50bf328a.js"><link rel="modulepreload" href="/assets/java_juc.html-c4967054.js"><link rel="prefetch" href="/assets/index.html-0ce61fa9.js" as="script"><link rel="prefetch" href="/assets/mysql_advance.html-d6219995.js" as="script"><link rel="prefetch" href="/assets/mysql_base.html-c6ab0552.js" as="script"><link rel="prefetch" href="/assets/mysql_high.html-55072139.js" as="script"><link rel="prefetch" href="/assets/interview.html-97c85ece.js" as="script"><link rel="prefetch" href="/assets/mongodb.html-0d0744b9.js" as="script"><link rel="prefetch" href="/assets/optimization.html-f016fef6.js" as="script"><link rel="prefetch" href="/assets/redis.html-6a25c044.js" as="script"><link rel="prefetch" href="/assets/java_jvm.html-d0967276.js" as="script"><link rel="prefetch" href="/assets/java_jvm_optimize.html-dd24d727.js" as="script"><link rel="prefetch" href="/assets/java_thread.html-3b0a9e41.js" as="script"><link rel="prefetch" href="/assets/java_thread_pool.html-75a567a4.js" as="script"><link rel="prefetch" href="/assets/java_base.html-056f7ff5.js" as="script"><link rel="prefetch" href="/assets/java_exception.html-9993d94e.js" as="script"><link rel="prefetch" href="/assets/java_Io.html-e3db5f8a.js" as="script"><link rel="prefetch" href="/assets/java_list.html-31f4b5fd.js" as="script"><link rel="prefetch" href="/assets/java_new8.html-6dd646ec.js" as="script"><link rel="prefetch" href="/assets/java_object.html-a7de2f70.js" as="script"><link rel="prefetch" href="/assets/java_reflect.html-08c2a157.js" as="script"><link rel="prefetch" href="/assets/java_simple.html-c32db0db.js" as="script"><link rel="prefetch" href="/assets/java_web.html-d7f68a67.js" as="script"><link rel="prefetch" href="/assets/java_jsp.html-64f622e2.js" as="script"><link rel="prefetch" href="/assets/java_servlet.html-9dd1dd2c.js" as="script"><link rel="prefetch" href="/assets/404.html-60b35caa.js" as="script"><link rel="prefetch" href="/assets/index.html-9c30ae09.js" as="script"><link rel="prefetch" href="/assets/mysql_advance.html-36744e2f.js" as="script"><link rel="prefetch" href="/assets/mysql_base.html-76d5b36b.js" as="script"><link rel="prefetch" href="/assets/mysql_high.html-6bf4bb7d.js" as="script"><link rel="prefetch" href="/assets/interview.html-44bef611.js" as="script"><link rel="prefetch" href="/assets/mongodb.html-9ce18145.js" as="script"><link rel="prefetch" href="/assets/optimization.html-029c0d29.js" as="script"><link rel="prefetch" href="/assets/redis.html-365e35d9.js" as="script"><link rel="prefetch" href="/assets/java_jvm.html-b46b586e.js" as="script"><link rel="prefetch" href="/assets/java_jvm_optimize.html-19e3c625.js" as="script"><link rel="prefetch" href="/assets/java_thread.html-87791478.js" as="script"><link rel="prefetch" href="/assets/java_thread_pool.html-dd60e235.js" as="script"><link rel="prefetch" href="/assets/java_base.html-d4efbd6b.js" as="script"><link rel="prefetch" href="/assets/java_exception.html-e16104bf.js" as="script"><link rel="prefetch" href="/assets/java_Io.html-16a286bf.js" as="script"><link rel="prefetch" href="/assets/java_list.html-761af11d.js" as="script"><link rel="prefetch" href="/assets/java_new8.html-a1e1909b.js" as="script"><link rel="prefetch" href="/assets/java_object.html-653740ef.js" as="script"><link rel="prefetch" href="/assets/java_reflect.html-d428cb40.js" as="script"><link rel="prefetch" href="/assets/java_simple.html-f3780249.js" as="script"><link rel="prefetch" href="/assets/java_web.html-bbbc7d6b.js" as="script"><link rel="prefetch" href="/assets/java_jsp.html-ff5b2ce7.js" as="script"><link rel="prefetch" href="/assets/java_servlet.html-22952a3e.js" as="script"><link rel="prefetch" href="/assets/404.html-46166703.js" as="script">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container"><!--[--><header class="navbar"><div class="toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a href="/" class=""><!----><span class="site-name">小头知识库</span></a></span><div class="navbar-items-wrapper" style=""><!--[--><!--]--><nav class="navbar-items can-hide"><!--[--><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="Java"><span class="title">Java</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="Java"><span class="title">Java</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>Java基础知识</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/Java/base/java_base.html" class="" aria-label="Java基础知识"><!--[--><!--]--> Java基础知识 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/Java/base/java_list.html" class="" aria-label="集合框架"><!--[--><!--]--> 集合框架 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/Java/base/java_Io.html" class="" aria-label="Java IO"><!--[--><!--]--> Java IO <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/Java/base/java_web.html" class="" aria-label="Java 网络编程"><!--[--><!--]--> Java 网络编程 <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>Java进阶知识</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/Java/progress/java_jvm.html" class="" aria-label="JVM"><!--[--><!--]--> JVM <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/Java/progress/java_jvm_optimize.html" class="" aria-label="JVM调优"><!--[--><!--]--> JVM调优 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/Java/progress/java_thread.html" class="" aria-label="并发编程"><!--[--><!--]--> 并发编程 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a aria-current="page" href="/Java/progress/java_juc.html" class="router-link-active router-link-exact-active router-link-active" aria-label="JUC"><!--[--><!--]--> JUC <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><!--]--></ul></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="数据库"><span class="title">数据库</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="数据库"><span class="title">数据库</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>Mysql</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/database/mysql_base.html" class="" aria-label="Mysql基础"><!--[--><!--]--> Mysql基础 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/database/mysql_high.html" class="" aria-label="Mysql高级"><!--[--><!--]--> Mysql高级 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/database/mysql_advance.html" class="" aria-label="Mysql进阶"><!--[--><!--]--> Mysql进阶 <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>Redis</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/redis/redis.html" class="" aria-label="Redis"><!--[--><!--]--> Redis <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>MongoDB</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/mongodb/mongodb.html" class="" aria-label="MongoDB"><!--[--><!--]--> MongoDB <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><!--]--></ul></div></div><div class="navbar-item"><a href="/others/" class="" aria-label="框架"><!--[--><!--]--> 框架 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/algorithm/" class="" aria-label="工具 "><!--[--><!--]--> 工具  <!--[--><!--]--></a></div><div class="navbar-item"><a href="/algorithm/" class="" aria-label="部署"><!--[--><!--]--> 部署 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/others/" class="" aria-label="算法"><!--[--><!--]--> 算法 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/others/" class="" aria-label="开发"><!--[--><!--]--> 开发 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/accumulate/" class="" aria-label="面试"><!--[--><!--]--> 面试 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/optimization/optimization.md/" class="" aria-label="项目优化"><!--[--><!--]--> 项目优化 <!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><button class="toggle-color-mode-button" title="toggle color mode"><svg style="" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg style="display:none;" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><form class="search-box" role="search"><input type="search" autocomplete="off" spellcheck="false" value><!----></form></div></header><!--]--><div class="sidebar-mask"></div><!--[--><aside class="sidebar"><nav class="navbar-items"><!--[--><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="Java"><span class="title">Java</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="Java"><span class="title">Java</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>Java基础知识</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/Java/base/java_base.html" class="" aria-label="Java基础知识"><!--[--><!--]--> Java基础知识 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/Java/base/java_list.html" class="" aria-label="集合框架"><!--[--><!--]--> 集合框架 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/Java/base/java_Io.html" class="" aria-label="Java IO"><!--[--><!--]--> Java IO <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/Java/base/java_web.html" class="" aria-label="Java 网络编程"><!--[--><!--]--> Java 网络编程 <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>Java进阶知识</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/Java/progress/java_jvm.html" class="" aria-label="JVM"><!--[--><!--]--> JVM <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/Java/progress/java_jvm_optimize.html" class="" aria-label="JVM调优"><!--[--><!--]--> JVM调优 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/Java/progress/java_thread.html" class="" aria-label="并发编程"><!--[--><!--]--> 并发编程 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a aria-current="page" href="/Java/progress/java_juc.html" class="router-link-active router-link-exact-active router-link-active" aria-label="JUC"><!--[--><!--]--> JUC <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><!--]--></ul></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="数据库"><span class="title">数据库</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="数据库"><span class="title">数据库</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>Mysql</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/database/mysql_base.html" class="" aria-label="Mysql基础"><!--[--><!--]--> Mysql基础 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/database/mysql_high.html" class="" aria-label="Mysql高级"><!--[--><!--]--> Mysql高级 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/database/mysql_advance.html" class="" aria-label="Mysql进阶"><!--[--><!--]--> Mysql进阶 <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>Redis</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/redis/redis.html" class="" aria-label="Redis"><!--[--><!--]--> Redis <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>MongoDB</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/mongodb/mongodb.html" class="" aria-label="MongoDB"><!--[--><!--]--> MongoDB <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><!--]--></ul></div></div><div class="navbar-item"><a href="/others/" class="" aria-label="框架"><!--[--><!--]--> 框架 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/algorithm/" class="" aria-label="工具 "><!--[--><!--]--> 工具  <!--[--><!--]--></a></div><div class="navbar-item"><a href="/algorithm/" class="" aria-label="部署"><!--[--><!--]--> 部署 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/others/" class="" aria-label="算法"><!--[--><!--]--> 算法 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/others/" class="" aria-label="开发"><!--[--><!--]--> 开发 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/accumulate/" class="" aria-label="面试"><!--[--><!--]--> 面试 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/optimization/optimization.md/" class="" aria-label="项目优化"><!--[--><!--]--> 项目优化 <!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><ul class="sidebar-items"><!--[--><li><p tabindex="0" class="sidebar-item sidebar-heading active">Java进阶 <!----></p><ul style="" class="sidebar-item-children"><!--[--><li><a href="/Java/progress/java_jvm.html" class="sidebar-item" aria-label="JVM"><!--[--><!--]--> JVM <!--[--><!--]--></a><!----></li><li><a href="/Java/progress/java_jvm_optimize.html" class="sidebar-item" aria-label="JVM调优"><!--[--><!--]--> JVM调优 <!--[--><!--]--></a><!----></li><li><a href="/Java/progress/java_thread.html" class="sidebar-item" aria-label="并发编程"><!--[--><!--]--> 并发编程 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/Java/progress/java_juc.html" class="router-link-active router-link-exact-active router-link-active sidebar-item active" aria-label="JUC"><!--[--><!--]--> JUC <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/Java/progress/java_juc.html#简介" class="router-link-active router-link-exact-active sidebar-item" aria-label="简介"><!--[--><!--]--> 简介 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/Java/progress/java_juc.html#atomic包" class="router-link-active router-link-exact-active sidebar-item" aria-label="Atomic包"><!--[--><!--]--> Atomic包 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/Java/progress/java_juc.html#什么是原子类" class="router-link-active router-link-exact-active sidebar-item" aria-label="什么是原子类"><!--[--><!--]--> 什么是原子类 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/Java/progress/java_juc.html#atomic包里的类" class="router-link-active router-link-exact-active sidebar-item" aria-label="Atomic包里的类"><!--[--><!--]--> Atomic包里的类 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/Java/progress/java_juc.html#cas" class="router-link-active router-link-exact-active sidebar-item" aria-label="CAS"><!--[--><!--]--> CAS <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/Java/progress/java_juc.html#cas是什么" class="router-link-active router-link-exact-active sidebar-item" aria-label="CAS是什么"><!--[--><!--]--> CAS是什么 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/Java/progress/java_juc.html#java中对cas的实现" class="router-link-active router-link-exact-active sidebar-item" aria-label="Java中对CAS的实现"><!--[--><!--]--> Java中对CAS的实现 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/Java/progress/java_juc.html#cas的缺陷" class="router-link-active router-link-exact-active sidebar-item" aria-label="CAS的缺陷"><!--[--><!--]--> CAS的缺陷 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/Java/progress/java_juc.html#juc里面的常见锁" class="router-link-active router-link-exact-active sidebar-item" aria-label="JUC里面的常见锁"><!--[--><!--]--> JUC里面的常见锁 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/Java/progress/java_juc.html#锁分类" class="router-link-active router-link-exact-active sidebar-item" aria-label="锁分类"><!--[--><!--]--> 锁分类 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/Java/progress/java_juc.html#按上锁方式划分" class="router-link-active router-link-exact-active sidebar-item" aria-label="按上锁方式划分"><!--[--><!--]--> 按上锁方式划分 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/Java/progress/java_juc.html#按特性划分" class="router-link-active router-link-exact-active sidebar-item" aria-label="按特性划分"><!--[--><!--]--> 按特性划分 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/Java/progress/java_juc.html#其他锁" class="router-link-active router-link-exact-active sidebar-item" aria-label="其他锁"><!--[--><!--]--> 其他锁 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/Java/progress/java_juc.html#synchronized和juc的锁对比" class="router-link-active router-link-exact-active sidebar-item" aria-label="Synchronized和JUC的锁对比"><!--[--><!--]--> Synchronized和JUC的锁对比 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/Java/progress/java_juc.html#锁原理分析" class="router-link-active router-link-exact-active sidebar-item" aria-label="锁原理分析"><!--[--><!--]--> 锁原理分析 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/Java/progress/java_juc.html#aqs" class="router-link-active router-link-exact-active sidebar-item" aria-label="AQS"><!--[--><!--]--> AQS <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/Java/progress/java_juc.html#reentrantlock源码分析-锁的获取" class="router-link-active router-link-exact-active sidebar-item" aria-label="ReentrantLock源码分析-锁的获取"><!--[--><!--]--> ReentrantLock源码分析-锁的获取 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/Java/progress/java_juc.html#reentrantlock源码分析-锁的释放" class="router-link-active router-link-exact-active sidebar-item" aria-label="ReentrantLock源码分析-锁的释放"><!--[--><!--]--> ReentrantLock源码分析-锁的释放 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/Java/progress/java_juc.html#公平锁和非公平锁源码实现区别" class="router-link-active router-link-exact-active sidebar-item" aria-label="公平锁和非公平锁源码实现区别"><!--[--><!--]--> 公平锁和非公平锁源码实现区别 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/Java/progress/java_juc.html#读写锁reentrantreadwritelock" class="router-link-active router-link-exact-active sidebar-item" aria-label="读写锁ReentrantReadWriteLock"><!--[--><!--]--> 读写锁ReentrantReadWriteLock <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/Java/progress/java_juc.html#锁优化" class="router-link-active router-link-exact-active sidebar-item" aria-label="锁优化"><!--[--><!--]--> 锁优化 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/Java/progress/java_juc.html#线程协作工具类" class="router-link-active router-link-exact-active sidebar-item" aria-label="线程协作工具类"><!--[--><!--]--> 线程协作工具类 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/Java/progress/java_juc.html#countdownlatch计数门闩" class="router-link-active router-link-exact-active sidebar-item" aria-label="CountDownLatch计数门闩"><!--[--><!--]--> CountDownLatch计数门闩 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/Java/progress/java_juc.html#semaphore信号量" class="router-link-active router-link-exact-active sidebar-item" aria-label="Semaphore信号量"><!--[--><!--]--> Semaphore信号量 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/Java/progress/java_juc.html#cyclicbarrier循环栅栏" class="router-link-active router-link-exact-active sidebar-item" aria-label="CyclicBarrier循环栅栏"><!--[--><!--]--> CyclicBarrier循环栅栏 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/Java/progress/java_juc.html#condition接口" class="router-link-active router-link-exact-active sidebar-item" aria-label="Condition接口"><!--[--><!--]--> Condition接口 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/Java/progress/java_juc.html#并发容器" class="router-link-active router-link-exact-active sidebar-item" aria-label="并发容器"><!--[--><!--]--> 并发容器 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/Java/progress/java_juc.html#什么是并发容器" class="router-link-active router-link-exact-active sidebar-item" aria-label="什么是并发容器"><!--[--><!--]--> 什么是并发容器 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/Java/progress/java_juc.html#常见并发容器特点总结" class="router-link-active router-link-exact-active sidebar-item" aria-label="常见并发容器特点总结"><!--[--><!--]--> 常见并发容器特点总结 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/Java/progress/java_juc.html#concurrenthashmap" class="router-link-active router-link-exact-active sidebar-item" aria-label="ConcurrentHashMap"><!--[--><!--]--> ConcurrentHashMap <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/Java/progress/java_juc.html#copyonwritearraylist" class="router-link-active router-link-exact-active sidebar-item" aria-label="CopyOnWriteArrayList"><!--[--><!--]--> CopyOnWriteArrayList <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/Java/progress/java_juc.html#并发队列" class="router-link-active router-link-exact-active sidebar-item" aria-label="并发队列"><!--[--><!--]--> 并发队列 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/Java/progress/java_juc.html#为什么要用队列" class="router-link-active router-link-exact-active sidebar-item" aria-label="为什么要用队列"><!--[--><!--]--> 为什么要用队列 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/Java/progress/java_juc.html#什么是阻塞队列" class="router-link-active router-link-exact-active sidebar-item" aria-label="什么是阻塞队列"><!--[--><!--]--> 什么是阻塞队列 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/Java/progress/java_juc.html#常用阻塞队列" class="router-link-active router-link-exact-active sidebar-item" aria-label="常用阻塞队列"><!--[--><!--]--> 常用阻塞队列 <!--[--><!--]--></a><!----></li><!--]--></ul></li><!--]--></ul></li><li><a href="/Java/progress/java_thread_pool.html" class="sidebar-item" aria-label="线程池"><!--[--><!--]--> 线程池 <!--[--><!--]--></a><!----></li><!--]--></ul></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="page"><!--[--><!--]--><div class="theme-default-content"><!--[--><!--]--><div><h1 id="juc" tabindex="-1"><a class="header-anchor" href="#juc" aria-hidden="true">#</a> JUC</h1><h2 id="简介" tabindex="-1"><a class="header-anchor" href="#简介" aria-hidden="true">#</a> 简介</h2><p>从JDK1.5起，Java API 中提供了java.util.concurrent（简称JUC）包，在此包中定义了并发 编程中很常用的工具。<br> JUC是 JSR 166 标准规范的一个实现，JSR 166 以及 JUC 包的作者是同一个人 Doug Lea 。</p><h2 id="atomic包" tabindex="-1"><a class="header-anchor" href="#atomic包" aria-hidden="true">#</a> Atomic包</h2><h3 id="什么是原子类" tabindex="-1"><a class="header-anchor" href="#什么是原子类" aria-hidden="true">#</a> 什么是原子类</h3><p>JDK1.5之后，JUC的atomic包中，提供了一系列用法简单、性能高效、线程安全的更新一个变量的类，这些称之为原子类。</p><p>作用：保证共享变量操作的原子性、可见性，可以解决volatile原子性操作变量的BUG</p><h3 id="atomic包里的类" tabindex="-1"><a class="header-anchor" href="#atomic包里的类" aria-hidden="true">#</a> Atomic包里的类</h3><p>➢基本类型：AtomicInteger整形原子类…<br> ➢引用类型：AtomicReference引用类型原子类…<br> ➢数组类型：AtomicIntegerArray整形数组原子类…<br> ➢对象属性修改类型：AtomicIntegerFieldUpdater原子更新整形字段的更新器…➢JDK1.8新增：DoubleAdder双浮点型原子类、LongAdder长整型原子类…</p><p>虽然原子类很多，但原理几乎都差不多，其核心是采用CAS进行原子操作</p><h2 id="cas" tabindex="-1"><a class="header-anchor" href="#cas" aria-hidden="true">#</a> CAS</h2><h3 id="cas是什么" tabindex="-1"><a class="header-anchor" href="#cas是什么" aria-hidden="true">#</a> CAS是什么</h3><p>CAS即compare and swap（比较再替换），同步组件中大量使用CAS技术实现了Java多线程的并发操作。整个AQS、Atomic原子类底层操作，都可以看见CAS。甚至ConcurrentHashMap在1.8的版本中也调整为了CAS+Synchronized。可以说CAS是整个JUC的基石。</p><p>CAS本质是一条CPU的原子指令，可以保证共享变量修改的原子性</p><p>其实，CAS本不难，它只是一个方法而已，这个方法长这样：执行函数：CAS(V,E,N)<br> ➢V：要读写的内存地址<br> ➢E：进行比较的值（预期值）<br> ➢N：拟写入的新值<br> ➢当且仅当内存地址的V 中的值等于预期值E 时，将内存地址的V中的值改为N，否则会进行自旋操作，即不断的重试。</p><img src="/images/thread/13.png" alt="jvm"><h3 id="java中对cas的实现" tabindex="-1"><a class="header-anchor" href="#java中对cas的实现" aria-hidden="true">#</a> Java中对CAS的实现</h3><img src="/images/thread/14.png" alt="jvm"><img src="/images/thread/15.png" alt="jvm"><h3 id="cas的缺陷" tabindex="-1"><a class="header-anchor" href="#cas的缺陷" aria-hidden="true">#</a> CAS的缺陷</h3><p>CAS虽然很好的解决了共享变量的原子操作问题，但还是有一些缺陷:<br> ➢循环时间不可控：如果CAS一直不成功，那么CAS自旋就是个死循环。会给CPU造成负担 ReentrantReadWriteLock读写锁：它维护了一对锁，ReadLock读锁和WriteLock写锁。读写锁适合读多写少的场景基本原则：读锁可以被多个线程同时持有进行访问，而写锁只能被一个线程持有。可以这 么理解：读写锁是个混合体，它既是一个共享锁，也是一个独享锁。 ➢StampedLock重入读写锁，JDK1.8引入的锁类型，是对读写锁ReentrantReadWriteLock的增强版。 ➢只能保证一个共享变量原子操作<br> ➢ABA问题：CAS检查操作的值有没有发生改变，如果没有则更新。这就存在一种情况：如果原来的值是A，然后变成了B，然后又变为A了，那么CAS检测不到数据发生了变化，但是其实数据已经改变了。</p><h2 id="juc里面的常见锁" tabindex="-1"><a class="header-anchor" href="#juc里面的常见锁" aria-hidden="true">#</a> JUC里面的常见锁</h2><p>JUC包提供了种类丰富的锁，每种锁特性各不相同<br> ➢ReentrantLock重入锁：它具有与使用synchronized 相同的一些基本行为和语义，但是它的API功能更强大，重入锁相当于synchronized 的增强版，具有synchronized很多所没有的功能。它是一种独享锁（互斥锁），可以是公平锁，也可以是非公平的锁。</p><p>➢ReentrantReadWriteLock读写锁：它维护了一对锁，ReadLock读锁和WriteLock写锁。读写锁适合读多写少的场景。基本原则：读锁可以被多个线程同时持有进行访问，而写锁只能被一个线程持有。可以这么理解：读写锁是个混合体，它既是一个共享锁，也是一个独享锁。</p><p>➢StampedLock重入读写锁，JDK1.8引入的锁类型，是对读写锁ReentrantReadWriteLock的增强版。</p><h3 id="锁分类" tabindex="-1"><a class="header-anchor" href="#锁分类" aria-hidden="true">#</a> 锁分类</h3><h3 id="按上锁方式划分" tabindex="-1"><a class="header-anchor" href="#按上锁方式划分" aria-hidden="true">#</a> 按上锁方式划分</h3><p>①隐式锁：synchronized，不需要显示加锁和解锁<br> ②显式锁：JUC包中提供的锁，需要显示加锁和解锁</p><h3 id="按特性划分" tabindex="-1"><a class="header-anchor" href="#按特性划分" aria-hidden="true">#</a> 按特性划分</h3><p>悲观锁/乐观锁：按照线程在使用共享资源时，要不要锁住同步资源，划分为悲观锁和乐观锁</p><ul><li>悲观锁：JUC锁，synchronized</li><li>乐观锁：CAS，关系型数据库的版本号机制</li></ul><p>重入锁/不可重入锁：按照同一个线程是否可以重复获取同一把锁，划分为重入锁和不可重入锁</p><ul><li>重入锁：ReentrantLock、synchronized</li><li>不可重入锁：不可重入锁，与可重入锁相反，线程获取锁之后不可重复获取锁，重复获取会发生死锁</li></ul><p>公平锁/非公平锁：按照多个线程竞争同一锁时需不需要排队，能不能插队，划分为公平锁和非公平锁。</p><ul><li>公平锁：new ReentrantLock(true)多个线程按照申请锁的顺序获取锁</li><li>非公平锁：new ReentrantLock(false)多个线程获取锁的顺序不是按照申请锁的顺序(可以插队) synchronized</li></ul><p>独享锁/共享锁：按照多个线程能不能同时共享同一个锁，锁被划分为独享锁和共享锁</p><ul><li>独享锁：独享锁也叫排他锁，synchronized，ReentrantLock，ReentrantReadWriteLock的WriteLock写锁</li><li>共享锁：ReentrantReadWriteLock的ReadLock读锁</li></ul><h3 id="其他锁" tabindex="-1"><a class="header-anchor" href="#其他锁" aria-hidden="true">#</a> 其他锁</h3><p>自旋锁：</p><ul><li>实现：CAS、轻量级锁</li></ul><p>分段锁：</p><ul><li>实现：ConcurrentHashMap ConcurrentHashMap所使用的锁分段技术，首先将数据分成一段一段的存储，然后给每一段数据配一把锁,当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。</li></ul><p>无锁/偏向锁/轻量级锁/重量级锁</p><ul><li>这四个锁是synchronized独有的四种状态，级别从低到高依次是：无锁、偏向锁、轻量级锁和重量级锁。</li><li>它们是JVM为了提高synchronized锁的获取与释放效率而做的优化</li><li>四种状态会随着竞争的情况逐渐升级，而且是不可逆的过程，即不可降级。</li></ul><h3 id="synchronized和juc的锁对比" tabindex="-1"><a class="header-anchor" href="#synchronized和juc的锁对比" aria-hidden="true">#</a> Synchronized和JUC的锁对比</h3><p>Synchronize的缺陷：<br> ➢ 第一： Synchronized无法控制阻塞时长，阻塞不可中断<br> ◼ 使用Synchronized，假如占有锁的线程被长时间阻塞（IO、sleep、join），由于线程阻塞时没法释放锁，会导致大 量线程堆积，轻则影响性能，重则服务雪崩<br> ◼ JUC的锁可以解决这两个缺陷<br> ➢ 第二：读多写少的场景中，多个读线程同时操作共享资源时不需要加锁<br> ◼ Synchronized不论是读还是写，均需要同步操作，这种做法并不是最优解<br> ◼ JUC的ReentrantReadWriteLock锁可以解决这个问题</p><h2 id="锁原理分析" tabindex="-1"><a class="header-anchor" href="#锁原理分析" aria-hidden="true">#</a> 锁原理分析</h2><p>在重入锁ReentrantLock类关系图中，可以看到NonfairSync和FairSync都继承自抽象类Sync，而Sync类继 承自抽象类AbstractQueuedSynchronizer（简称AQS）。</p><img src="/images/thread/16.png" alt="jvm"><h3 id="aqs" tabindex="-1"><a class="header-anchor" href="#aqs" aria-hidden="true">#</a> AQS</h3><p>AQS即队列同步器，是JUC并发包中的核心基础组件，其本身只是一个抽象类。其实现原理与前面介绍的 Monitor管程是一样的，AQS中也用到了CAS和Volatile。</p><p>由类图可以看到，AQS是一个FIFO的双向队列，队列中存储的是thread，其内部通过节点head和tail记录队首 和队尾元素，队列元素的类型为Node</p><img src="/images/thread/17.png" alt="jvm"><p>AQS中的内部静态类Node为链表节点，AQS会在线程获取锁失败后，线程会被阻塞并被封装成Node加入到 AQS队列中；当获取锁的线程释放锁后，会从AQS队列中的唤醒一个线程（节点）。</p><img src="/images/thread/18.png" alt="jvm"><ul><li>线程抢夺锁失败时，AQS队列的变化【加锁】</li></ul><p>① AQS的head、tail分别代表同步队列头节点和尾节点指针默认为null<br> ② 当第一个线程抢夺锁失败，同步队列会先初始化，随后线程会被封装成Node节点追加到AQS队列中。<br> ➢ 假设：当前独占锁的的线程为ThreadA，抢占锁失败的线程为ThreadB。<br> ➢ 2.1 同步队列初始化，首先在队列中添加Node，thread=null<br> ➢ 2.2 将ThreadB封装成为Node，追加到AQS队列<br> ③ 当下一个线程抢夺锁失败时，继续重复上面步骤。假设：ThreadC抢占线程失败</p><img src="/images/thread/19.png" alt="jvm"><ul><li>线程被唤醒时，AQS队列的变化【解锁】</li></ul><p>① ReentrantLock唤醒阻塞线程时，会按照FIFO的原则从AQS中head头部开始唤醒首个节点中线程。<br> ② head节点表示当前获取锁成功的线程ThreadA节点。<br> ③ 当ThreadA释放锁时，它会唤醒后继节点线程ThreadB，ThreadB开始尝试获得锁，如果ThreadB获得锁成功，会将自 己设置为AQS的头节点。ThreadB获取锁成功后，AQS变化如下：</p><img src="/images/thread/20.png" alt="jvm"><h3 id="reentrantlock源码分析-锁的获取" tabindex="-1"><a class="header-anchor" href="#reentrantlock源码分析-锁的获取" aria-hidden="true">#</a> ReentrantLock源码分析-锁的获取</h3><p>ReentrantLock锁获取源码分析：</p><img src="/images/thread/21.png" alt="jvm"><h3 id="reentrantlock源码分析-锁的释放" tabindex="-1"><a class="header-anchor" href="#reentrantlock源码分析-锁的释放" aria-hidden="true">#</a> ReentrantLock源码分析-锁的释放</h3><p>ReentrantLock锁释放源码分析</p><img src="/images/thread/22.png" alt="jvm"><h3 id="公平锁和非公平锁源码实现区别" tabindex="-1"><a class="header-anchor" href="#公平锁和非公平锁源码实现区别" aria-hidden="true">#</a> 公平锁和非公平锁源码实现区别</h3><p>公平锁/非公平锁：按照多个线程竞争同一锁时需不需要排队，能不能插队<br> 获取锁的两处差异：<br> ① lock方法差异<br> ② tryAcquire差异</p><img src="/images/thread/23.png" alt="jvm"><img src="/images/thread/24.png" alt="jvm"><h3 id="读写锁reentrantreadwritelock" tabindex="-1"><a class="header-anchor" href="#读写锁reentrantreadwritelock" aria-hidden="true">#</a> 读写锁ReentrantReadWriteLock</h3><p>读写锁：维护着一对锁(读锁和写锁)，通过分离读锁和写锁，使得并发能力比一般的互斥锁有较大 提升。同一时间，可以允许多个读线程同时访问，但在写线程访问时，所有读写线程都会阻塞。 所以说，读锁是共享的，写锁是排他的。</p><p>主要特性：<br> ➢ 支持公平和非公平锁<br> ➢ 支持重入<br> ➢ 锁降级：写锁可以降级为读锁，但是读锁不能升级为写锁</p><img src="/images/thread/25.png" alt="jvm"><h3 id="锁优化" tabindex="-1"><a class="header-anchor" href="#锁优化" aria-hidden="true">#</a> 锁优化</h3><p>如何优化锁？</p><p>➢ 减少锁的持有时间<br> ➢ 减少锁粒度<br> ◆ 将大对象拆分为小对象，增加并行度，降低锁的竞争<br> ◆ 例如：早期ConcurrentHashMap的分段锁<br> ➢ 锁分离<br> ◆ 根据功能场景进行锁分离<br> ◆ 例如：读多写少的场景，使用读写锁可以提高性能<br> ➢ 锁消除：锁消除是编译器自动的一种优化方式<br> ➢ 锁粗化<br> ◆ 增加锁的范围，降低加解锁的频次</p><h2 id="线程协作工具类" tabindex="-1"><a class="header-anchor" href="#线程协作工具类" aria-hidden="true">#</a> 线程协作工具类</h2><h3 id="countdownlatch计数门闩" tabindex="-1"><a class="header-anchor" href="#countdownlatch计数门闩" aria-hidden="true">#</a> CountDownLatch计数门闩</h3><p>◆ 倒数结束之前，一直处于等待状态，直到数到0，等待线程才继续工作。<br> ◆ 场景：购物拼团、分布式锁<br> ◆ 方法：<br> ① new CountDownLatch(int count)<br> ② await()：调用此方法的线程会阻塞，支持多个线程调用，当计数为0，则唤醒线程<br> ③ countdown()：其他线程调用此方法，计数减1</p><h3 id="semaphore信号量" tabindex="-1"><a class="header-anchor" href="#semaphore信号量" aria-hidden="true">#</a> Semaphore信号量</h3><p>◆ 限制和管理数量有限的资源的使用<br> ◆ 场景：Hystrix、Sentinel限流<br> ◆ 方法：<br> ① new Semaphore ((int permits) 可以创建公平的非公平的策略<br> ② acquire()：获取许可证，获取许可证，要么获取成功，信号量减1，要么阻塞等待唤醒<br> ③ release()：释放许可证，信号量加1，然后唤醒等待的线程</p><h3 id="cyclicbarrier循环栅栏" tabindex="-1"><a class="header-anchor" href="#cyclicbarrier循环栅栏" aria-hidden="true">#</a> CyclicBarrier循环栅栏</h3><p>◆ 线程会等待，直到线程到了事先规定的数目，然后触发执行条件进行下一步动作<br> ◆ 场景：并行计算<br> ◆ 方法：<br> ① new CyclicBarrier(int parties, Runnable barrierAction)参数1集结线程数，参数2凑齐之后执行的任务<br> ② await()：阻塞当前线程，待凑齐线程数量之后继续执行</p><h3 id="condition接口" tabindex="-1"><a class="header-anchor" href="#condition接口" aria-hidden="true">#</a> Condition接口</h3><p>◆ 控制线程的“等待”和“唤醒”<br> ◆ 方法：<br> ① await()：阻塞线程<br> ② signal()：唤醒被阻塞的线程<br> ③ signalAll()会唤起所有正在等待的线程。<br> ◆ 注意：<br> ① 调用await()方法时必须持有锁，否则会抛出异常<br> ② Condition和Object#await/notify方法用法一样，两者await方法都会释放锁</p><img src="/images/thread/26.png" alt="jvm"><h2 id="并发容器" tabindex="-1"><a class="header-anchor" href="#并发容器" aria-hidden="true">#</a> 并发容器</h2><h3 id="什么是并发容器" tabindex="-1"><a class="header-anchor" href="#什么是并发容器" aria-hidden="true">#</a> 什么是并发容器</h3><p>针对多线程并发访问来进行设计的集合，称为并发容器<br> ➢ JDK1.5之前，JDK提供了线程安全的集合都是同步容器，线程安全，只能串行执行，性能很差。<br> ➢ JDK1.5之后，JUC并发包提供了很多并发容器，优化性能，替代同步容器</p><img src="/images/thread/27.png" alt="jvm"><p>什么是同步容器？线程安全的集合与非安全集合有什么关系？</p><p>每次只有一个线程可以访问的集合（同步），称为线程安全的集合，也叫同步容器<br> ➢ Java集合主要为4类：List、Map、Set、Queue，线程不安全的：ArrayList、HashMap..<br> ➢ JDK早期线程安全的集合Vector、Stack、HashTable。<br> ➢ JDK1.2中，还为Collections增加内部Synchronized类创建出线程安全的集合，实现原理synchronized</p><h3 id="常见并发容器特点总结" tabindex="-1"><a class="header-anchor" href="#常见并发容器特点总结" aria-hidden="true">#</a> 常见并发容器特点总结</h3><p>➢ List容器<br> ① Vector：synchronized实现的同步容器，性能差，适合于对数据有强一致性要求的场景<br> ② CopyOnWriteArrayList ：底层数组实现，使用复制副本进行有锁写操作（数据不一致问题），适合读多写少，允 许短暂的数据不一致的场景<br> ➢ Map容器<br> ① Hashtable ： synchronized实现的同步容器，性能差，适合于对数据有强一致性要求的场景<br> ② ConcurrentHashMap ：底层数组+链表+红黑树（JDK1.8）实现，对table数组entry加锁（ synchronized ）， 存在一致性问题。适合存储数据量小，读多写少，允许短暂的数据不一致的场景<br> ③ ConcurrentSkipListMap ：底层跳表实现，使用CAS实现无锁读写操作。适合与存储数据量大，读写频繁，允许短 暂的数据不一致的场景<br> ➢ Set容器<br> ① CopyOnWriteArraySet ：底层数组实现的无序Set<br> ② ConcurrentSkipListSet ：底层基于跳表实现的有序Set</p><h3 id="concurrenthashmap" tabindex="-1"><a class="header-anchor" href="#concurrenthashmap" aria-hidden="true">#</a> ConcurrentHashMap</h3><p>JDK1.7结构图<br><img src="/images/thread/28.png" alt="jvm"></p><p>JDK1.8结构图<br> ➢ 底层采用数组+链表+红黑树数据结构<br> ➢ 存入key值，使用hashCode映射数组索引<br> ➢ 集合会自动扩容：加载因子0.75f<br> ➢ 链表长度超过8时，链表转换为红黑树</p><img src="/images/thread/29.png" alt="jvm"><h3 id="copyonwritearraylist" tabindex="-1"><a class="header-anchor" href="#copyonwritearraylist" aria-hidden="true">#</a> CopyOnWriteArrayList</h3><p>CopyOnWriteArrayList底层数组实现，使用复制副本进行有锁写操作，适合读多写少，允许短 暂的数据不一致的场景。<br> CopyOnWrite思想：平时查询时，不加锁，更新时从原来的数据copy副本，然后修改副本，最后把原数据 替换为副本。修改时，不阻塞读操作，读到的是旧数据</p><p>优缺点<br> ➢ 优点：对于读多写少的场景， CopyOnWrite这种无锁操作性能更好，相比于其它同步容器<br> ➢ 缺点：①数据一致性问题，②内存占用问题及导致更多的GC次数</p><h2 id="并发队列" tabindex="-1"><a class="header-anchor" href="#并发队列" aria-hidden="true">#</a> 并发队列</h2><h3 id="为什么要用队列" tabindex="-1"><a class="header-anchor" href="#为什么要用队列" aria-hidden="true">#</a> 为什么要用队列</h3><p>队列是线程协作的利器，通过队列可以很容易的实现数据共享，并且解决上下游处理速度不匹配的问题，典型的生 产者消费者模式</p><h3 id="什么是阻塞队列" tabindex="-1"><a class="header-anchor" href="#什么是阻塞队列" aria-hidden="true">#</a> 什么是阻塞队列</h3><p>➢ 带阻塞能力的队列，阻塞队列一端是给生产者put数据使用，另一端给消费者take数据使用<br> ➢ 阻塞队列是线程安全的，生产者和消费者都可以是多线程<br> ➢ take方法：获取并移除头元素，如果队列无数据，则阻塞<br> ➢ put方法：插入元素，如果队列已满，则阻塞<br> ➢ 阻塞队列又分为有界和无界队列，无界队列不是无限队列，最大值Integer.MAX_VALUE</p><h3 id="常用阻塞队列" tabindex="-1"><a class="header-anchor" href="#常用阻塞队列" aria-hidden="true">#</a> 常用阻塞队列</h3><ol><li>ArrayBlockingQueue 基于数组实现的有界阻塞队列</li><li>LinkedBlockingQueue 基于链表实现的无界阻塞队列</li><li>SynchronousQueue不存储元素的阻塞队列</li><li>PriorityBlockingQueue 支持按优先级排序的无界阻塞队列</li><li>DelayQueue优先级队列实现的双向无界阻塞队列</li><li>LinkedTransferQueue基于链表实现的无界阻塞队列</li><li>LinkedBlockingDeque基于链表实现的双向无界阻塞队列</li></ol></div><!--[--><!--]--></div><footer class="page-meta"><!----><div class="meta-item last-updated"><span class="meta-item-label">Last Updated: </span><!----></div><div class="meta-item contributors"><span class="meta-item-label">Contributors: </span><span class="meta-item-info"><!--[--><!--[--><span class="contributor" title="email: xt@qq.com">xt</span><!----><!--]--><!--]--></span></div></footer><nav class="page-nav"><p class="inner"><span class="prev"><a href="/Java/progress/java_thread.html" class="" aria-label="并发编程"><!--[--><!--]--> 并发编程 <!--[--><!--]--></a></span><span class="next"><a href="/Java/progress/java_thread_pool.html" class="" aria-label="线程池"><!--[--><!--]--> 线程池 <!--[--><!--]--></a></span></p></nav><!--[--><!--]--></main><!--]--></div><!----><!--]--></div>
    <script type="module" src="/assets/app-97ed9e93.js" defer></script>
  </body>
</html>
