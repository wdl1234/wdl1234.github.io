const l=JSON.parse('{"key":"v-319bb9c0","path":"/Java/progress/java_thread.html","title":"并发编程","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"概念","slug":"概念","link":"#概念","children":[{"level":3,"title":"线程和进程","slug":"线程和进程","link":"#线程和进程","children":[]},{"level":3,"title":"并发和并行","slug":"并发和并行","link":"#并发和并行","children":[]},{"level":3,"title":"线程上下文切换","slug":"线程上下文切换","link":"#线程上下文切换","children":[]}]},{"level":2,"title":"线程的基本实现方式","slug":"线程的基本实现方式","link":"#线程的基本实现方式","children":[{"level":3,"title":"1、继承Thread类","slug":"_1、继承thread类","link":"#_1、继承thread类","children":[]},{"level":3,"title":"2、实现Runnable接口","slug":"_2、实现runnable接口","link":"#_2、实现runnable接口","children":[]},{"level":3,"title":"3、Callable和Future创建线程","slug":"_3、callable和future创建线程","link":"#_3、callable和future创建线程","children":[]}]},{"level":2,"title":"线程状态","slug":"线程状态","link":"#线程状态","children":[{"level":3,"title":"wait与sleep()的区别","slug":"wait与sleep-的区别","link":"#wait与sleep-的区别","children":[]}]},{"level":2,"title":"多线程源码剖析","slug":"多线程源码剖析","link":"#多线程源码剖析","children":[]},{"level":2,"title":"线程安全","slug":"线程安全","link":"#线程安全","children":[{"level":3,"title":"线程安全问题","slug":"线程安全问题","link":"#线程安全问题","children":[]},{"level":3,"title":"引发线程安全问题的根本原因","slug":"引发线程安全问题的根本原因","link":"#引发线程安全问题的根本原因","children":[]},{"level":3,"title":"解决线程安全问题","slug":"解决线程安全问题","link":"#解决线程安全问题","children":[]}]},{"level":2,"title":"线程并发三大特性","slug":"线程并发三大特性","link":"#线程并发三大特性","children":[{"level":3,"title":"指令重排","slug":"指令重排","link":"#指令重排","children":[]},{"level":3,"title":"CPU和缓存一致性","slug":"cpu和缓存一致性","link":"#cpu和缓存一致性","children":[]},{"level":3,"title":"Java内存模型","slug":"java内存模型","link":"#java内存模型","children":[]},{"level":3,"title":"JMM内存模型抽象结构示意图","slug":"jmm内存模型抽象结构示意图","link":"#jmm内存模型抽象结构示意图","children":[]},{"level":3,"title":"JMM线程操作内存基本规则","slug":"jmm线程操作内存基本规则","link":"#jmm线程操作内存基本规则","children":[]},{"level":3,"title":"可见性","slug":"可见性","link":"#可见性","children":[]},{"level":3,"title":"happens-before规则","slug":"happens-before规则","link":"#happens-before规则","children":[]}]},{"level":2,"title":"线程同步-synchronized","slug":"线程同步-synchronized","link":"#线程同步-synchronized","children":[{"level":3,"title":"作用","slug":"作用","link":"#作用","children":[]},{"level":3,"title":"如何解决可见性问题","slug":"如何解决可见性问题","link":"#如何解决可见性问题","children":[]},{"level":3,"title":"Synchronized是如何实现同步","slug":"synchronized是如何实现同步","link":"#synchronized是如何实现同步","children":[]},{"level":3,"title":"synchronized原理","slug":"synchronized原理","link":"#synchronized原理","children":[]},{"level":3,"title":"锁优化","slug":"锁优化","link":"#锁优化","children":[]}]},{"level":2,"title":"Volatile关键字","slug":"volatile关键字","link":"#volatile关键字","children":[{"level":3,"title":"Volatile简介","slug":"volatile简介","link":"#volatile简介","children":[]},{"level":3,"title":"Volatile实现原理","slug":"volatile实现原理","link":"#volatile实现原理","children":[]},{"level":3,"title":"JMM 内存屏障插入策略","slug":"jmm-内存屏障插入策略","link":"#jmm-内存屏障插入策略","children":[]},{"level":3,"title":"Volatile缺陷","slug":"volatile缺陷","link":"#volatile缺陷","children":[]},{"level":3,"title":"Volatile和Synchronized特点比较","slug":"volatile和synchronized特点比较","link":"#volatile和synchronized特点比较","children":[]}]}],"git":{"updatedTime":1684158432000,"contributors":[{"name":"xt","email":"xt@qq.com","commits":1}]},"filePathRelative":"Java/progress/java_thread.md"}');export{l as data};
