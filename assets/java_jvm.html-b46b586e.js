import{_ as t,p,q as o,R as s,t as a,a1 as e}from"./framework-96b046e1.js";const l={},c=e('<h1 id="jvm" tabindex="-1"><a class="header-anchor" href="#jvm" aria-hidden="true">#</a> JVM</h1><h2 id="基本常识" tabindex="-1"><a class="header-anchor" href="#基本常识" aria-hidden="true">#</a> 基本常识</h2><h3 id="jvm是什么" tabindex="-1"><a class="header-anchor" href="#jvm是什么" aria-hidden="true">#</a> JVM是什么</h3>',3),i=["src"],r=s("h3",{id:"jvm架构图",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#jvm架构图","aria-hidden":"true"},"#"),a(" JVM架构图")],-1),u=["src"],d=s("h3",{id:"java技术体系",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#java技术体系","aria-hidden":"true"},"#"),a(" Java技术体系")],-1),m=["src"],k=s("h3",{id:"java与jvm的关系",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#java与jvm的关系","aria-hidden":"true"},"#"),a(" Java与JVM的关系")],-1),h=["src"],v=s("h2",{id:"类加载系统",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#类加载系统","aria-hidden":"true"},"#"),a(" 类加载系统")],-1),g=s("h3",{id:"类加载器种类",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#类加载器种类","aria-hidden":"true"},"#"),a(" 类加载器种类")],-1),b=s("p",null,"JVM的类加载是通过ClassLoader及其子类来完成的",-1),j=["src"],_=["src"],w=["src"],f=s("h3",{id:"执行顺序",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#执行顺序","aria-hidden":"true"},"#"),a(" 执行顺序")],-1),C=["src"],B=s("h3",{id:"类加载四个时机",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#类加载四个时机","aria-hidden":"true"},"#"),a(" 类加载四个时机")],-1),G=["src"],S=s("h3",{id:"生命周期",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#生命周期","aria-hidden":"true"},"#"),a(" 生命周期")],-1),$=["src"],y=s("h3",{id:"类加载途径",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#类加载途径","aria-hidden":"true"},"#"),a(" 类加载途径")],-1),M=["src"],O=s("h3",{id:"双亲委派模型",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#双亲委派模型","aria-hidden":"true"},"#"),a(" 双亲委派模型")],-1),P=["src"],R=["src"],X=["src"],q=["src"],J=s("h2",{id:"运行时数据区",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#运行时数据区","aria-hidden":"true"},"#"),a(" 运行时数据区")],-1),T=s("h3",{id:"运行时数据区构成",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#运行时数据区构成","aria-hidden":"true"},"#"),a(" 运行时数据区构成")],-1),U=s("p",null,"堆 栈 本地方法栈 方法区 程序计数器",-1),V=["src"],A=s("h3",{id:"堆",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#堆","aria-hidden":"true"},"#"),a(" 堆")],-1),H=["src"],L=["src"],Z=["src"],N=["src"],W=["src"],E=s("h3",{id:"栈",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#栈","aria-hidden":"true"},"#"),a(" 栈")],-1),I=s("p",null,"栈帧：",-1),D=["src"],K=s("p",null,"当前栈帧：",-1),z=["src"],F=["src"],Q=["src"],x=s("h3",{id:"本地方法栈",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#本地方法栈","aria-hidden":"true"},"#"),a(" 本地方法栈")],-1),Y=["src"],ss=s("h3",{id:"方法区",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#方法区","aria-hidden":"true"},"#"),a(" 方法区")],-1),ns=s("p",null,"方法区概念:",-1),as=["src"],es=["src"],ts=["src"],ps=["src"],os=["src"],ls=["src"],cs=s("h3",{id:"程序计数器",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#程序计数器","aria-hidden":"true"},"#"),a(" 程序计数器")],-1),is=["src"],rs=s("h3",{id:"字符串常量池",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#字符串常量池","aria-hidden":"true"},"#"),a(" 字符串常量池")],-1),us=["src"],ds=["src"],ms=s("h2",{id:"对象生命周期",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#对象生命周期","aria-hidden":"true"},"#"),a(" 对象生命周期")],-1),ks=s("h3",{id:"创建过程",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#创建过程","aria-hidden":"true"},"#"),a(" 创建过程")],-1),hs=["src"],vs=s("h3",{id:"对象内存分配方式",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#对象内存分配方式","aria-hidden":"true"},"#"),a(" 对象内存分配方式")],-1),gs=s("p",null,"内存分配的方法有两种：不同垃圾收集器不一样",-1),bs=s("ul",null,[s("li",null,"指针碰撞(Bump the Pointer)"),s("li",null,"空闲列表(Free List)")],-1),js=["src"],_s=["src"],ws=s("h3",{id:"内存分配安全问题",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#内存分配安全问题","aria-hidden":"true"},"#"),a(" 内存分配安全问题")],-1),fs=s("p",null,"在分配内存的时候，虚拟机给A线程分配内存过程中，指针未修改。此时B线程同时使用了同样一块内 存。是不是就出现了线程的安全性问题？",-1),Cs=s("p",null,"在JVM中有两种解决办法：",-1),Bs=s("ol",null,[s("li",null,"CAS 是乐观锁的一种实现方式。虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。"),s("li",null,"TLAB本地线程分配缓冲(Thread Local Allocation Buffer即TLAB)：为每一个线程预先分配一块内存")],-1),Gs=s("p",null,"JVM在第一次给线程中的对象分配内存时，首先进行TLAB的分配。当对象大于TLAB中的剩余内 存或TLAB的内存已用尽时，再采用上述的CAS进行内存分配。",-1),Ss=s("h3",{id:"对象分配流程",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#对象分配流程","aria-hidden":"true"},"#"),a(" 对象分配流程")],-1),$s=["src"],ys=e('<h3 id="对象怎样才会进入老年代" tabindex="-1"><a class="header-anchor" href="#对象怎样才会进入老年代" aria-hidden="true">#</a> 对象怎样才会进入老年代</h3><p>对象内存分配：</p><ul><li>新生代：新对象大多数都默认进入新生代的Eden区</li><li>进入老年代的条件：四种情况<br> 1:存活年龄太大，默认超过15次【-XX:MaxTenuringThreshold】<br> 2:动态年龄判断：MinorGC之后，发现Survivor区中的一批对象的总大小大于了这块Survivor区 的50%，那么就会将此时大于等于这批对象年龄最大值的所有对象，直接进入老年代。<br> 3:大对象直接进入老年代：前提是Serial和ParNew收集器<br> 4:MinorGC后，存活对象太多无法放入Survivor</li></ul><p>空间担保机制：当新生代无法分配内存的时候，我们想把新生代的老对象转移到老年代，然后把新对象 放入腾空的新生代。此种机制我们称之为内存担保。</p><h3 id="老年代的担保示意图" tabindex="-1"><a class="header-anchor" href="#老年代的担保示意图" aria-hidden="true">#</a> 老年代的担保示意图</h3>',5),Ms=["src"],Os=s("h3",{id:"对象三个区",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#对象三个区","aria-hidden":"true"},"#"),a(" 对象三个区")],-1),Ps=["src"],Rs=e('<p>堆内存中，一个对象在内存中存储的布局可以分为三块区域：</p><ol><li>对象头（Header）：Java对象头占12字节,数组加4字节</li></ol><ul><li><p>标记字段MarkWord：<br> 用于存储对象自身的运行时数据，它是synchronized实现轻量级锁和偏向锁的关键。<br> 默认存储：对象HashCode、GC分代年龄、锁状态等等信息。<br> 为了节省空间，也会随着锁标志位的变化，存储数据发生变化</p></li><li><p>类型指针KlassPoint：<br> 是对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例<br> 开启指针压缩存储空间4byte，不开启8byte。<br> JDK1.6+默认开启</p></li><li><p>数组长度：如果对象是数组，则记录数组长度，占4个byte，如果对象不是数组则不存在。</p></li></ul><ol start="2"><li><p>实例数据（Instance Data）：生成对象的时候，对象的非静态成员变量也会存入堆空间</p></li><li><p>对齐填充（Padding）：JVM内对象都采用8byte对齐，不够8byte的会自动补齐。</p></li></ol><h3 id="标记字段" tabindex="-1"><a class="header-anchor" href="#标记字段" aria-hidden="true">#</a> 标记字段</h3><p>在32位系统中，一个字是32bit，也就是4字节。64位系统中，一个字是64bit，也就是8字节。</p>',6),Xs=["src"],qs=e(`<h3 id="打印对象内存布局信息" tabindex="-1"><a class="header-anchor" href="#打印对象内存布局信息" aria-hidden="true">#</a> 打印对象内存布局信息</h3><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token generics"><span class="token punctuation">&lt;</span>dependency<span class="token punctuation">&gt;</span></span>
<span class="token generics"><span class="token punctuation">&lt;</span>groupId<span class="token punctuation">&gt;</span></span>org<span class="token punctuation">.</span>openjdk<span class="token punctuation">.</span>jol<span class="token operator">&lt;</span><span class="token operator">/</span>groupId<span class="token operator">&gt;</span>
<span class="token generics"><span class="token punctuation">&lt;</span>artifactId<span class="token punctuation">&gt;</span></span>jol<span class="token operator">-</span>core<span class="token operator">&lt;</span><span class="token operator">/</span>artifactId<span class="token operator">&gt;</span>
<span class="token generics"><span class="token punctuation">&lt;</span>version<span class="token punctuation">&gt;</span></span><span class="token number">0.9</span><span class="token operator">&lt;</span><span class="token operator">/</span>version<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>dependency<span class="token operator">&gt;</span>



<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>openjdk<span class="token punctuation">.</span>jol<span class="token punctuation">.</span>info<span class="token punctuation">.</span></span><span class="token class-name">ClassLayout</span></span><span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ObjLock01</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token class-name">Object</span> o <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;new Object:&quot;</span> <span class="token operator">+</span>
<span class="token class-name">ClassLayout</span><span class="token punctuation">.</span><span class="token function">parseInstance</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toPrintable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>结论：空对象大小 = 对象头12 + 实例数据0 + 对齐填充4 = 16 bytes</p><h3 id="如何访问对象" tabindex="-1"><a class="header-anchor" href="#如何访问对象" aria-hidden="true">#</a> 如何访问对象</h3><p>有两种方式：</p><ol><li>句柄：稳定，对象被移动只要修改句柄中的地址</li><li>直接指针：访问速度快，节省了一次指针定位的开销</li></ol>`,6),Js=["src"],Ts=["src"],Us=e('<h2 id="垃圾回收" tabindex="-1"><a class="header-anchor" href="#垃圾回收" aria-hidden="true">#</a> 垃圾回收</h2><h3 id="什么是垃圾" tabindex="-1"><a class="header-anchor" href="#什么是垃圾" aria-hidden="true">#</a> 什么是垃圾</h3><p>在内存中，没有被引用的对象就是垃圾。</p><h3 id="如何找到垃圾" tabindex="-1"><a class="header-anchor" href="#如何找到垃圾" aria-hidden="true">#</a> 如何找到垃圾</h3><p>1、引用计数法（Reference Counting）</p>',5),Vs=["src"],As=e('<p>在堆内存中主要的引用关系有如下三种：单一引用、循环引用、无引用（垃圾）</p><p>2、根可达算法（GCRoots Tracing）</p><p>基本思路就是通过一系列的名为“GCRoot”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的 路径称为引用链（Reference Chain），当一个对象到GCRoot没有任何引用链相连时，则证明此对象 是不可用的，也就是不可达的。</p><p>可作GCRoots的对象：</p><ul><li>虚拟机栈中，栈帧的本地变量表引用的对象。</li><li>方法区中，类静态属性引用的对象。</li><li>方法区中，常量引用的对象。</li><li>本地方法栈中，JNl引用的对象。</li></ul><h3 id="回收过程" tabindex="-1"><a class="header-anchor" href="#回收过程" aria-hidden="true">#</a> 回收过程</h3><p>即使在可达性分析算法中不可达的对象，也并非是“非死不可”。被判定不可达的对象处于“缓刑”阶段。 要真正宣告死亡，至少要经历两次标记过程：<br> 第一次标记：如果对象可达性分析后，发现没有与GC Roots相连接的引用链，那它将会被第一次标 记；<br> 第二次标记：第一次标记后，接着会进行一次筛选。筛选条件：此对象是否有必要执行 finalize() 方法。在 finalize() 方法中没有重新与引用链建立关联关系的，将被进行第二次标 记。</p><p>第二次标记成功的对象将真的会被回收，如果失败则继续存活</p><h3 id="对象引用" tabindex="-1"><a class="header-anchor" href="#对象引用" aria-hidden="true">#</a> 对象引用</h3><p>在JDK1.2之后，Java对引用的概念进行了扩充，将引用分为强引用（StrongReference）、软引用 （SoftReference）、弱引用（WeakReference）、虚引用（PhantomReference）四种，这四种引 用强度依次逐渐减弱</p>',10),Hs=["src"],Ls=e(`<ol><li>强引用<br> 代码中普遍存在，只要强引用还在，就不会被GC。</li></ol><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Object</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ol start="2"><li>软引用<br> 非必须引用，内存溢出之前进行回收，如内存还不够，才会抛异常。</li></ol><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Object</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">SoftReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> sf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SoftReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
obj <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token class-name">Object</span> o <span class="token operator">=</span> sf<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//有时候会返回null</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;o = &quot;</span> <span class="token operator">+</span> o<span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>应用场景：软引用可用来实现内存敏感的高速缓存。</p><ol start="3"><li>弱引用</li></ol><p>非必须引用，只要有GC，就会被回收。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Object</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">WeakReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> wf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeakReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
obj <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token comment">//System.gc();</span>
<span class="token class-name">Object</span> o <span class="token operator">=</span> wf<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//有时候会返回null</span>
<span class="token keyword">boolean</span> enqueued <span class="token operator">=</span> wf<span class="token punctuation">.</span><span class="token function">isEnqueued</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//返回是否被垃圾回收器标记为即将回收的垃圾</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;o = &quot;</span> <span class="token operator">+</span> o<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;enqueued = &quot;</span> <span class="token operator">+</span> enqueued<span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>弱引用是在第二次垃圾回收时回收，短时间内通过弱引用取对应的数据，可以取到，当执行过第二 次垃圾回收时，将返回null。<br> 作用：监控对象是否已经被垃圾回收器标记为即将回收的垃圾，可以通过弱引用的isEnQueued方 法返回对象是否被垃圾回收器标记。</p><ol start="4"><li>虚引用</li></ol><p>虚引用是最弱的一种引用关系。垃圾回收时直接回收</p><p>一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对 象实例</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Object</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">PhantomReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> pf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PhantomReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token keyword">new</span>
<span class="token class-name">ReferenceQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
obj<span class="token operator">=</span><span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token class-name">Object</span> o <span class="token operator">=</span> pf<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//永远返回null</span>
<span class="token keyword">boolean</span> enqueued <span class="token operator">=</span> pf<span class="token punctuation">.</span><span class="token function">isEnqueued</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//返回是否从内存中已经删除</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;o = &quot;</span> <span class="token operator">+</span> o<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;enqueued = &quot;</span> <span class="token operator">+</span> enqueued<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>虚引用是每次垃圾回收的时候都会被回收，通过虚引用的get方法永远获取到的数据为null，因此也 被成为幽灵引用。<br> 作用：跟踪对象被垃圾回收的状态，仅仅是提供一种确保对象被回收后，做某些事情的机制。类似 事件监听机制</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Object</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">PhantomReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> pf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PhantomReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token keyword">new</span>
<span class="token class-name">ReferenceQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
obj<span class="token operator">=</span><span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token class-name">Object</span> o <span class="token operator">=</span> pf<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//永远返回null</span>
<span class="token keyword">boolean</span> enqueued <span class="token operator">=</span> pf<span class="token punctuation">.</span><span class="token function">isEnqueued</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//返回是否从内存中已经删除</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;o = &quot;</span> <span class="token operator">+</span> o<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;enqueued = &quot;</span> <span class="token operator">+</span> enqueued<span class="token punctuation">)</span><span class="token punctuation">;</span>   

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="如何清除垃圾" tabindex="-1"><a class="header-anchor" href="#如何清除垃圾" aria-hidden="true">#</a> 如何清除垃圾</h3><p>JVM提供3种方法，清除垃圾对象：</p><ul><li>Mark-Sweep 标记清除算法</li><li>Copying 拷贝算法</li><li>Mark-Compact 标记压缩算法</li></ul>`,18),Zs=s("br",null,null,-1),Ns=s("br",null,null,-1),Ws=["src"],Es=s("p",null,[a("缺点："),s("br"),a(" 效率不高，标记和清除过程的效率都不高"),s("br"),a(" 空间碎片，会产生大量不连续的内存碎片，会导致大对象可能无法分配，提前触发GC")],-1),Is=s("p",null,"2）拷贝算法（Copying）",-1),Ds=s("p",null,[a("为解决效率。它将可用内存按容量划分为相等的两块，每次只使用其中的一块。当这一块的内存用完 了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。"),s("br"),a(" 现在商业虚拟机都是采用这种收集算法来回收新生代，当回收时，将Eden和Survivor中还存活着的对象 拷贝到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor的空间。"),s("br"),a(" HotSpot虚拟机默认Eden和Survivor的大小比例是8：1，也就是每次新生代中可用内存空间为整个新生 代容量的90%（80%+10%），只有10%的内存是会被“浪费”的。当Survivor空间不够用时，需要依赖其 他内存（这里指老年代）进行分配担保（Handle Promotion）")],-1),Ks=["src"],zs=s("p",null,"优点：没有碎片化，所有的有用的空间都连接在一起，所有的空闲空间都连接在一起",-1),Fs=s("p",null,"缺点：存在空间浪费",-1),Qs=s("p",null,"3）标记-整理算法（Mark-Compact）",-1),xs=s("p",null,"老年代没有人担保，不能用复制回收算法。可以用标记-整理算法，标记过程仍然与“标记-清除”算法一 样，然后让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存",-1),Ys=["src"],sn=e('<p>缺点：性能较低，因为除了拷贝对象以外，还需要对象内存空间进行压缩，所以性能较低。</p><p>当前商业虚拟机都是采用这种算法。根据对象的存活周期的不同将内存划分为几块。<br> 新生代，每次垃圾回收都有大量对象失去，选择复制算法。<br> 老年代，对象存活率高，无人进行分配担保，就必须采用标记清除或者标记整理算法</p><h3 id="垃圾回收器" tabindex="-1"><a class="header-anchor" href="#垃圾回收器" aria-hidden="true">#</a> 垃圾回收器</h3><p>有 8 种不同的垃圾回收器，它们分别用于不同分代的垃圾回收。<br> 新生代回收器：Serial、ParNew、Parallel Scavenge<br> 老年代回收器：Serial Old、Parallel Old、CMS<br> 整堆回收器：G1、ZGC</p><h3 id="串行收集器" tabindex="-1"><a class="header-anchor" href="#串行收集器" aria-hidden="true">#</a> 串行收集器</h3><p>使用单线程进行垃圾回收的收集器，每次回收时，串行收集器只有一个工作线程，对于并行能力较弱的 计算机来说，串行收集器性能会更好。</p><p>计算机来说，串行收集器性能会更好。 串行收集器可以在新生代和老年代中使用，根据作用于不同的堆空间，分为新生代串行收集器和老年代 收集器。</p><p>配置参数 -XX:+UseSerialGC ：年轻串行（Serial），老年串行（Serial Old）</p><p>1、Serial收集器：年轻串行</p><p>Serial收集器是新生代收集器，单线程执行，使用复制算法。<br> 进行垃圾收集时，必须暂停其他所有的工作线程。<br> 对于单个CPU的环境来说，Serial收集器由于没有线程交互的开销，收集效率更高。</p>',10),nn=["src"],an=e('<p>2、Serial Old收集器：老年串行</p><p>Serial收集器的老年代版本，它同样是一个单线程收集器，使用“标记-整理”算法。</p><h3 id="并行收集器" tabindex="-1"><a class="header-anchor" href="#并行收集器" aria-hidden="true">#</a> 并行收集器</h3><p>1、 Parallel Scavenge收集器</p><p>配置参数： -XX:+UseParallelGC<br> 目标是达到一个可控制的吞吐量（Throughput）</p><p>特点：<br> 吞吐量优先收集器<br> 新生代使用并行回收收集器，采用复制算法<br> 老年代使用串行收集器</p>',6),en=["src"],tn=s("p",null,"2、 Parallel Old收集器",-1),pn=s("p",null,"配置参数： -XX:+UseParallelOldGC",-1),on=s("p",null,[a("特点： Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法。"),s("br"),a(" 在注重吞吐量，CPU资源敏感的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器。")],-1),ln=["src"],cn=s("p",null,"3、ParNew收集器",-1),rn=s("p",null,[a("配置参数： -XX:+UseParNewGC"),s("br"),a(" 配置参数： -XX:ParallelGCThreads=n 设置并行收集器收集时使用的并行收集线程数。一般最好和计 算机的CPU相当")],-1),un=s("p",null,[a("特点："),s("br"),a(" 新生代并行（ParNew），老年代串行（Serial Old）"),s("br"),a(" Serial收集器的多线程版本")],-1),dn=s("br",null,null,-1),mn=["src"],kn=e("<p>4、CMS收集器</p><p>配置参数： -XX:+UseConcMarkSweepGC 应用CMS收集器。</p><p>尽管CMS收集器采用的是并发回收，但是在其初始标记和重新标记这两个阶段中仍然需要执行“STW”暂 停程序中的工作线程，不过暂停时间并不会太长，目前所有的垃圾收集器都做不到完全不需要“STW”， 只是尽可能地缩短暂停时间。<br> 由于最耗费时间的并发标记与并发清除阶段都不需要暂停工作，所以整体的回收是低停顿的。另外，由 于在垃圾收集阶段用户线程没有中断，所以在CMS回收过程中，还应该确保应用程序用户线程有足够的 内存可用</p><p>特点:<br> 低延迟：减少STW对用户体验的影响【低延迟要求高】<br> 并发收集：可以同时执行用户线程<br> CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，而是当堆内存使用率 达到某一阈值时，便开始进行回收。<br> CMS收集器的垃圾收集算法采用的是标记-清除算法, 会产生内存碎片，导致并发清除后，用户线程可用的空间不足。<br> CMS收集器对CPU资源非常敏感。</p>",4),hn=["src"],vn=e("<p>CMS整个过程比之前的收集器要复杂，整个过程分为4个主要阶段：<br> 初始标记（Initial-Mark）阶段：<br> 本阶段任务：标记出GCRoots能直接关联到的对象。<br> 一旦标记完成之后就会恢复之前被暂停的所有应用线程。<br> 由于直接关联对象比较小，所以这里的速度非常快。<br> 会STW<br> 并发标记（Concurrent-Mark）阶段：<br> 本阶段任务：从GC Roots的直接关联对象遍历整个对象图<br> 这个过程耗时较长<br> 不会STW<br> 重新标记（Remark）阶段：<br> 本阶段任务：修正并发标记期间，因用户程序继续运作产生的新的对象记录<br> 这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短。<br> 会STW<br> 并发清除（Concurrent-Sweep）阶段：<br> 本阶段任务：清理删除掉标记阶段判断的已经死亡的对象，释放内存空间。<br> 由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的。</p><p>5、 G1（Garbage-First）收集器<br> Garbage First（简称G1）收集器是垃圾收集器技术发展历史上的里程碑式的成果，它开创了收集器面向 局部收集的设计思路和基于Region的内存布局形式。</p><p>G1是一款面向服务端应用的垃圾收集器，大内存企业配置的垃圾收集器大多都是G1。<br> JDK 9发布之日G1宣告取代Parallel Scavenge加Parallel Old组合，成为服务端模式下的默认垃圾收 集器，而CMS则被声明为不推荐使用（Deprecate）。</p><p>G1最大堆内存是 32MB<em>2048=64G ，G1最小堆内存 1MB</em>2048=2GB ，低于此值建议使用其它收集器。</p><p>特点：</p><ol><li>并行与并发：充分利用多核环境下的硬件优势</li><li>多代收集：不需要其他收集器配合就能独立管理整个GC堆</li><li>空间整合：“标记-整理”算法实现的收集器，局部上基于“复制”算法不会产生内存空间碎片</li><li>可预测的停顿：能让使用者明确指定消耗在垃圾收集上的时间。当然，更短的GC时间的代价是回 收空间的效率降低。</li></ol>",6),gn=["src"],bn=e(`<p>G1收集器的运作大致可划分为以下几个步骤：</p><ol><li>初始标记：标记一下GC Roots能直接关联到的对象，需要停顿线程，但耗时很短</li><li>并发标记：是从GC Root开始对堆中对象进行可达性分析，找出存活的对象，这阶段耗时较长，但 可与用户程序并发执行</li><li>最终标记：修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录</li><li>筛选回收：对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收 计划<br> G1中有三种模式垃圾回收模式，Young GC、Mixed GC 和 Full GC，在不同的条件下被触发。</li></ol><p>G1内存划分<br> G1垃圾收集器相对比其他收集器而言，最大的区别在于它取消了新生代、老年代的物理划分，取而代之 的是将堆划分为若干个区域（Region），这些区域中包含了有逻辑上的新生代、老年代区域。<br> 好处：不用单独的空间对每个代进行设置，不用考虑每个代内存如何分配。</p><p>局部采用复制算法：<br> G1新生代垃圾收集依然采用暂停所有应用线程的方式，将存活对象拷贝到老年代或者Survivor空间<br> G1通过将对象从一个区域复制到另外一个区域，完成了清理工作。 相当于在正常的处理过程中， G1完成了堆的压缩，这样就不会有cms内存碎片问题了。</p><p>Humongous区域：在G1中，有一种特殊的区域叫Humongous区域<br> 如果一个对象占用的空间超过了分区容量50%以上，G1收集器就认为这是一个巨型对象。 这些巨 型对象，默认直接会被分配在老年代。<br> 但是，如果是一个短期存在的巨型对象，在分区之间来回拷贝，就会对垃圾收集器造成负面影响。 为了解决这个问题，G1划分了Humongous区，它用来专门存放巨型对象。如果一个H区装不下一 个巨型对象，那么G1会寻找连续的H分区来存储。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token operator">-</span><span class="token constant">XX</span><span class="token operator">:</span><span class="token operator">+</span><span class="token class-name">UseG1GC</span>
# 使用 <span class="token constant">G1</span> 垃圾收集器
<span class="token operator">-</span><span class="token constant">XX</span><span class="token operator">:</span><span class="token class-name">MaxGCPauseMillis</span><span class="token operator">=</span>
# 设置期望达到的最大<span class="token constant">GC</span>停顿时间指标（<span class="token constant">JVM</span>会尽力实现，但不保证达到），默认值是 <span class="token number">200</span> 毫秒。
<span class="token operator">-</span><span class="token constant">XX</span><span class="token operator">:</span><span class="token class-name">G1HeapRegionSize</span><span class="token operator">=</span>n
# 设置的 <span class="token constant">G1</span> 区域的大小。值是 <span class="token number">2</span> 的幂，范围是 <span class="token number">1</span> <span class="token constant">MB</span> 到 <span class="token number">32</span> <span class="token constant">MB</span> 之间。
# 目标是根据最小的 <span class="token class-name">Java</span> 堆大小划分出约 <span class="token number">2048</span> 个区域。
# 默认是堆内存的<span class="token number">1</span><span class="token operator">/</span><span class="token number">2000</span>。
<span class="token operator">-</span><span class="token constant">XX</span><span class="token operator">:</span><span class="token class-name">ParallelGCThreads</span><span class="token operator">=</span>n
# 设置并行垃圾回收线程数，一般将n的值设置为逻辑处理器的数量，建议最多为<span class="token number">8</span>。
<span class="token operator">-</span><span class="token constant">XX</span><span class="token operator">:</span><span class="token class-name">ConcGCThreads</span><span class="token operator">=</span>n
# 设置并行标记的线程数。将n设置为<span class="token class-name">ParallelGCThreads</span>的<span class="token number">1</span><span class="token operator">/</span><span class="token number">4</span>左右。
<span class="token operator">-</span><span class="token constant">XX</span><span class="token operator">:</span><span class="token class-name">InitiatingHeapOccupancyPercent</span><span class="token operator">=</span>n
# 设置触发标记周期的 <span class="token class-name">Java</span> 堆占用率阈值。默认占用率是整个 <span class="token class-name">Java</span> 堆的 <span class="token number">45</span><span class="token operator">%</span>。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>6、ZGC（Z Garbage Collector）</p><p>Z Garbage Collector，也称为ZGC，在 JDK11 中引入的一种可扩展的低延迟垃圾收集器，在 JDK15 中 发布稳定版</p><p>ZGC的目标：<br> &lt; 1ms 最大暂停时间（jdk &lt; 16 是 10ms，jdk &gt;=16 是 &lt;1ms ）<br> 暂停时间不会随着堆、live-set 或 root-set 的大小而增加<br> 适用内存大小从 8MB 到16TB 的堆</p><p>ZGC 具有以下特征：<br> 并发<br> 基于 region<br> 压缩<br> NUMA 感知<br> 使用彩色指针<br> 使用负载屏障</p><p>ZGC 收集器是一款基于 Region 内存布局的， 不设分代的，使用了读屏障、染色指针和内存多重映射等 技术来实现可并发的标记-整理算法的，以低延迟为首要目标的一款垃圾收集器。ZGC 的核心是一个并发 垃圾收集器，这意味着所有繁重的工作都在Java 线程继续执行的同时完成。这极大地限制了垃圾收集对 应用程序响应时间的影响。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token operator">-</span><span class="token constant">XX</span><span class="token operator">:</span><span class="token operator">+</span><span class="token class-name">UseZGC</span> # 启用 <span class="token constant">ZGC</span>
<span class="token operator">-</span><span class="token class-name">Xmx</span> # 设置最大堆内存
<span class="token operator">-</span><span class="token class-name">Xlog</span><span class="token operator">:</span>gc # 打印 <span class="token constant">GC</span>日志
<span class="token operator">-</span><span class="token class-name">Xlog</span><span class="token operator">:</span>gc<span class="token operator">*</span> # 打印 <span class="token constant">GC</span> 详细日志
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>总结:<br> 在众多的垃圾回收器中，没有最好的，只有最适合应用的回收器，根据应用软件的特性以及硬件平台的 特点，选择不同的垃圾回收器，才能有效的提高系统性能。【小马拉大车、大车驮小马的现象都不合 理！】</p>`,13);function jn(n,_n){return p(),o("div",null,[c,s("img",{src:n.$withBase("/images/jvm/2.png"),alt:"jvm"},null,8,i),r,s("img",{src:n.$withBase("/images/jvm/1.png"),alt:"jvm"},null,8,u),d,s("img",{src:n.$withBase("/images/jvm/3.png"),alt:"jvm"},null,8,m),k,s("img",{src:n.$withBase("/images/jvm/4.png"),alt:"jvm"},null,8,h),v,g,b,s("img",{src:n.$withBase("/images/jvm/5.png"),alt:"jvm"},null,8,j),s("img",{src:n.$withBase("/images/jvm/6.png"),alt:"jvm"},null,8,_),s("img",{src:n.$withBase("/images/jvm/7.png"),alt:"jvm"},null,8,w),f,s("img",{src:n.$withBase("/images/jvm/9.png"),alt:"jvm"},null,8,C),B,s("img",{src:n.$withBase("/images/jvm/10.png"),alt:"jvm"},null,8,G),S,s("img",{src:n.$withBase("/images/jvm/11.png"),alt:"jvm"},null,8,$),y,s("img",{src:n.$withBase("/images/jvm/12.png"),alt:"jvm"},null,8,M),O,s("img",{src:n.$withBase("/images/jvm/13.png"),alt:"jvm"},null,8,P),s("img",{src:n.$withBase("/images/jvm/14.png"),alt:"jvm"},null,8,R),s("img",{src:n.$withBase("/images/jvm/15.png"),alt:"jvm"},null,8,X),s("img",{src:n.$withBase("/images/jvm/16.png"),alt:"jvm"},null,8,q),J,T,U,s("img",{src:n.$withBase("/images/jvm/17.png"),alt:"jvm"},null,8,V),A,s("p",null,[a("概念："),s("img",{src:n.$withBase("/images/jvm/18.png"),alt:"jvm"},null,8,H)]),s("p",null,[a("内存划分： "),s("img",{src:n.$withBase("/images/jvm/19.png"),alt:"jvm"},null,8,L)]),s("img",{src:n.$withBase("/images/jvm/20.png"),alt:"jvm"},null,8,Z),s("p",null,[a("内存模型变迁： "),s("img",{src:n.$withBase("/images/jvm/21.png"),alt:"jvm"},null,8,N)]),s("img",{src:n.$withBase("/images/jvm/22.png"),alt:"jvm"},null,8,W),E,I,s("img",{src:n.$withBase("/images/jvm/23.png"),alt:"jvm"},null,8,D),K,s("img",{src:n.$withBase("/images/jvm/24.png"),alt:"jvm"},null,8,z),s("p",null,[a("栈帧创建时间: "),s("img",{src:n.$withBase("/images/jvm/25.png"),alt:"jvm"},null,8,F)]),s("p",null,[a("栈异常的两种情况: "),s("img",{src:n.$withBase("/images/jvm/26.png"),alt:"jvm"},null,8,Q)]),x,s("img",{src:n.$withBase("/images/jvm/27.png"),alt:"jvm"},null,8,Y),ss,ns,s("img",{src:n.$withBase("/images/jvm/28.png"),alt:"jvm"},null,8,as),s("p",null,[a("方法区存的数据: "),s("img",{src:n.$withBase("/images/jvm/29.png"),alt:"jvm"},null,8,es)]),s("img",{src:n.$withBase("/images/jvm/30.png"),alt:"jvm"},null,8,ts),s("p",null,[a("永久代与元空间区别: "),s("img",{src:n.$withBase("/images/jvm/31.png"),alt:"jvm"},null,8,ps)]),s("img",{src:n.$withBase("/images/jvm/32.png"),alt:"jvm"},null,8,os),s("p",null,[a("方法区实现变迁历史: "),s("img",{src:n.$withBase("/images/jvm/33.png"),alt:"jvm"},null,8,ls)]),cs,s("img",{src:n.$withBase("/images/jvm/36.png"),alt:"jvm"},null,8,is),rs,s("img",{src:n.$withBase("/images/jvm/34.png"),alt:"jvm"},null,8,us),s("img",{src:n.$withBase("/images/jvm/35.png"),alt:"jvm"},null,8,ds),ms,ks,s("img",{src:n.$withBase("/images/jvm/37.png"),alt:"jvm"},null,8,hs),vs,gs,bs,s("img",{src:n.$withBase("/images/jvm/38.png"),alt:"jvm"},null,8,js),s("img",{src:n.$withBase("/images/jvm/39.png"),alt:"jvm"},null,8,_s),ws,fs,Cs,Bs,Gs,Ss,s("img",{src:n.$withBase("/images/jvm/40.png"),alt:"jvm"},null,8,$s),ys,s("img",{src:n.$withBase("/images/jvm/41.png"),alt:"jvm"},null,8,Ms),Os,s("img",{src:n.$withBase("/images/jvm/42.png"),alt:"jvm"},null,8,Ps),Rs,s("img",{src:n.$withBase("/images/jvm/43.png"),alt:"jvm"},null,8,Xs),qs,s("img",{src:n.$withBase("/images/jvm/44.png"),alt:"jvm"},null,8,Js),s("img",{src:n.$withBase("/images/jvm/45.png"),alt:"jvm"},null,8,Ts),Us,s("img",{src:n.$withBase("/images/jvm/46.png"),alt:"jvm"},null,8,Vs),a(" 当这个对象引用都消失了，消失一个计数减一，当引用都消失了，计数就会变为0。此时这个对象就会变 成垃圾 "),As,s("img",{src:n.$withBase("/images/jvm/47.png"),alt:"jvm"},null,8,Hs),Ls,s("p",null,[a("1）标记清除算法（Mark-Sweep）"),Zs,a(" 最基本的算法，主要分为标记和清除2个阶段。首先标记出所有需要回收的对象，在标记完成后统一回收 掉所有被标记的对象"),Ns,s("img",{src:n.$withBase("/images/jvm/48.png"),alt:"jvm"},null,8,Ws)]),Es,Is,Ds,s("img",{src:n.$withBase("/images/jvm/49.png"),alt:"jvm"},null,8,Ks),zs,Fs,Qs,xs,s("img",{src:n.$withBase("/images/jvm/50.png"),alt:"jvm"},null,8,Ys),sn,s("img",{src:n.$withBase("/images/jvm/51.png"),alt:"jvm"},null,8,nn),an,s("img",{src:n.$withBase("/images/jvm/52.png"),alt:"jvm"},null,8,en),tn,pn,on,s("img",{src:n.$withBase("/images/jvm/53.png"),alt:"jvm"},null,8,ln),cn,rn,un,s("p",null,[a("注意：单CPU性能并不如Serial，因为存在线程交互的开销"),dn,s("img",{src:n.$withBase("/images/jvm/54.png"),alt:"jvm"},null,8,mn)]),kn,s("img",{src:n.$withBase("/images/jvm/55.png"),alt:"jvm"},null,8,hn),vn,s("img",{src:n.$withBase("/images/jvm/56.png"),alt:"jvm"},null,8,gn),bn])}const fn=t(l,[["render",jn],["__file","java_jvm.html.vue"]]);export{fn as default};
